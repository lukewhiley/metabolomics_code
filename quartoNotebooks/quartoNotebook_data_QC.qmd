---
title: Heidelberg data QC
subtitle: Tryptophan
author: Luke Whiley
date: "`r format(Sys.time(), '%d %B, %Y')`"
format:
  html:
    code-fold: true
    code-tools: true
    df-print: paged
    toc: true
    toc-depth: 5
    self-contained: TRUE
editor: visual
theme: cosmo
---

```{r notebook instructions, eval=FALSE}
# Quarto notebook for metabolomics data quality control
# Notebook will perform the following tasks:
# import data that has been exported from processing software
# create calibration, QC data, filter data, report data
# Notebook instructions:
  #>Enter user options in chunk 1
  #> project folder must be set up as ~parent_directory and include the subdirectories:
        #>  ~parent_directory/data
        #>  ~parent_directory/SIL_template
  #> default data type: import = .txt; export = .csv

# required packages: 'tidyverse', 'janitor', 'qualV', 'kableExtra', 'plotly', 'manipulateWidget', 'RColorBrewer', 'ropls'

```

## Data import

<!--# USER INPUT HERE -->

```{r user setup; project structure, eval=TRUE, echo=TRUE}
#USER INPUT REQUIRED BELOW
#enter the ~parent_directory loaction here
parent_directory_path = "/Users/lukegraywhiley/Downloads/temp_data/test_qc/"

#----------------------------- NO USER INPUTE REQUIRED BELOW THIS LINE
#----------------------------- set project structure
package_list <- c('tidyverse', 'janitor', 'qualV', 'kableExtra', 'plotly', 'manipulateWidget', 'RColorBrewer', 'ropls')

for(idx_package in package_list){
  if(length(which(row.names(installed.packages()) == idx_package)) > 0){
    suppressMessages(require(package = idx_package,
                             character.only = TRUE))
  } else {
    paste0(idx_package, " is not installed. Please install ", idx_package, " before continuing.") %>% print()
  }
}

#----------------------------- set project structure
mstr_lst <- list(
  proj_optns = list(
    #proj_name = "QC testR; Tryptophan", #name of project
    #usr_name = "LGW", #user of project
    proj_dir = parent_directory_path,
    proj_data_subdir = "data",# sub directory contatining export data from TargetLynx
    proj_SILtemplate_subdir = "SIL_template",
    data_type = ".txt", # import flie type [.txt as default]
    keep_header = c("area") # header to keep [e.g c("response", "conc", "area") etc]
  )) %>% 
  list_modify(
  data = list(
    imprt_lst = list.files(paste0(.$proj_optns$proj_dir, .$proj_optns$proj_data_subdir), full.names = TRUE, pattern = ".txt"),
    plate_lst = list.files(paste0(.$proj_optns$proj_dir, .$proj_optns$proj_data_subdir), full.names = FALSE, pattern = ".txt"),
    SIL_template = read.csv(
      file = list.files(paste0(.$proj_optns$proj_dir, .$proj_optns$proj_SILtemplate_subdir), full.names = TRUE)),
    std_conc = list(),
    area = list(),
    response = list()),
  tbls = list(
    imprt_tbl = list(),
    calib_summary = list(tibble("metabolite" = character(), "data_type" = character(), "reason" = character()))),
  control_charts = list(),
  calib = list(
    conc = list(),
    response = list(),
    area = list()
  )
)


```

-   Data is imported into R from .txt files produced in targetlynx (Waters inc.).

-   Once imported data is reorganized from a long .txt export into managable dataframes and appended to a master data list

-   Data import summary:

```{r read in and flip data, eval=TRUE, echo=TRUE, paged.print=TRUE, warning=FALSE, results='asis'}
#--------- read in data from targetlynx
#--------- write flippR function
targetlynx_flippR <- function(FUNC_txt_file_path,
                              FUNC_keep_hdr){
flippR_list <- list(
  #read.txt and convert to tibble
  data = read.delim(file = paste(FUNC_txt_file_path), sep = "\t",header=FALSE) %>% as_tibble() %>%
    #find row with column names
         set_names(., .[which(. == "Name", arr.ind=TRUE)[1,1],]) %>% clean_names()) %>%
  #append list of metabolites to flippR list
    list_modify(
      metabolites = unique(
        .$data$x[grep("Compound", .$data$x)]) %>% .[-grep("Report", .)] %>% sub(".*:  ", "", .), 
      #remove rows with empty space
      filtered_data = filter(.$data ,name != "" & name != "Name")
      ) %>% 
  list_modify(
    #flag duplicated samples
    duplicate_samples = .$filtered_data[1:(length(unique(.$filtered_data$x))),][["name"]] %>% duplicated()
  ) 
#flag duplicates
flippR_list$filtered_data$name[flippR_list$duplicate_samples] <- paste0(
  flippR_list$filtered_data$name[flippR_list$duplicate_samples],"_DUPLICATED")
#spread data
 flippR_list <- flippR_list %>%
   list_modify(
      spread_data = add_column(.$filtered_data, 
                               metabolite = rep(.$metabolites, 
                                                each = length(unique(.$filtered_data$name)))) %>% 
        select(name, type, metabolite,  all_of(FUNC_keep_hdr)) %>% 
        mutate_at(.vars = all_of(FUNC_keep_hdr), .funs = as.numeric) %>%
        spread(key = metabolite, value = all_of(FUNC_keep_hdr))
      )
    flippR_list$spread_data
  }

#--------- apply flippR function to files in ~parent_directory/data subfolder
#run flippR function and keep area and std_concs
for(idx_file in 1:length(mstr_lst$data$imprt_lst)){
  mstr_lst$data[["std_conc"]] <- mstr_lst$data[["std_conc"]] %>%
    bind_rows(targetlynx_flippR(FUNC_txt_file_path = mstr_lst$data$imprt_lst[idx_file], FUNC_keep_hdr = "std_conc") %>%
                add_column(plate = rep(unlist(str_split(mstr_lst$data$plate_lst[idx_file], "_"))[6], nrow(.)), .before = 1))
 mstr_lst$data[["area"]] <- mstr_lst$data[["area"]] %>%
    bind_rows(targetlynx_flippR(FUNC_txt_file_path = mstr_lst$data$imprt_lst[idx_file], FUNC_keep_hdr = "area") %>%
                add_column(plate = rep(unlist(str_split(mstr_lst$data$plate_lst[idx_file], "_"))[6], nrow(.)), .before = 1))

 #create summary table for report printing
mstr_lst$tbls[["imprt_tbl"]] <- bind_rows(
  mstr_lst$tbls[["imprt_tbl"]],
  bind_cols(plate = unlist(str_split(mstr_lst$data$plate_lst[idx_file], "_"))[6],
            standards = nrow(
              mstr_lst$data$std_conc %>% 
                filter(plate == unlist(str_split(mstr_lst$data$plate_lst[idx_file], "_"))[6] & type == "Standard")),
            qc = nrow(
              mstr_lst$data$std_conc %>% 
                filter(plate == unlist(str_split(mstr_lst$data$plate_lst[idx_file], "_"))[6] & type == "QC")),
            samples = nrow(
              mstr_lst$data$std_conc %>% 
                filter(plate == unlist(str_split(mstr_lst$data$plate_lst[idx_file], "_"))[6] & type == "Analyte")),
            blanks = nrow(
              mstr_lst$data$std_conc %>% 
                filter(plate == unlist(str_split(mstr_lst$data$plate_lst[idx_file], "_"))[6] & type == "Blank")),
            features = ncol(mstr_lst$data$std_conc)-2
            ))
}
#add summary row for all plates
mstr_lst$tbls$imprt_tbl <- mstr_lst$tbls$imprt_tbl %>%
  bind_rows(tibble(
    plate = "total", standards = sum(.$standards), qc = sum(.$qc), samples = sum(.$samples), 
    blanks = sum(.$blanks), features = sum(.$features))
  )

#print table in report
mstr_lst$tbls$imprt_tbl %>%
  kbl(align = "c", booktabs = TRUE, longtable = TRUE) %>%
  kable_minimal("hover") %>%
  kable_styling(font_size = 12) %>%
  scroll_box() %>% print()


```

## Control charts - Calibration and QC samples

```{r Cal and QC control charts FUNCTION, eval=TRUE, echo=TRUE, paged.print=FALSE, warning=FALSE}
#--------------------------------------------------------------------------------------------------------------------------- 
#FUNCTION Cal and QC control_plotR
#--------------------------------------------------------------------------------------------------------------------------- 
# requires a dataframe with column headers plate, name, type, level, area, response, SIL area

CalQC_controlPlotR <- function(FUNC_data){
  #change "Standard" annotation to "Calibration"
  FUNC_data$type[which(FUNC_data$type == "Standard")] <- "Calibration"
  #set level factor to control plotting
  FUNC_data$level_factor <- paste0(FUNC_data$type, "_", FUNC_data$std_conc) 
  FUNC_data$level_factor <- factor(FUNC_data$level_factor,
                                   levels = unique((FUNC_data %>% arrange(type, std_conc))[["level_factor"]]),
                                   ordered = TRUE)
  #turn into long table to allow for facet wrap
  FUNC_data <- FUNC_data %>%
    gather(key = "datatype", value = "value", -plate, - name, -type, - std_conc, - level_factor)
  #set type as factor to control facetwrap
  FUNC_data$type <- factor(paste0(FUNC_data$type, "_", FUNC_data$datatype),
                           #levels = sort(unique(paste0(FUNC_data$type, "_", FUNC_data$datatype))),
                           levels = c("Calibration_area", "QC_area", "Calibration_area_SIL", "QC_area_SIL", "Calibration_response", "QC_response"),
                           ordered = TRUE)
  #set plot colors and group to control plotly legend
  plot_colours <- c(brewer.pal(n = length(unique(FUNC_data$level_factor)), name = "Set3")) %>% 
    setNames(unique(FUNC_data$level_factor))
  #set plot size and group to control plotly legend
  plot_shape <- rep(21, length(unique(FUNC_data$level_factor))) %>% 
    setNames(unique(FUNC_data$level_factor))
  #set plot fill to black to aid visuals and group to control plotly legend
  plot_fill <- rep("black", length(unique(FUNC_data$level_factor))) %>% 
    setNames(unique(FUNC_data$level_factor))
  #create ggplot
  FUNC_plot <- ggplot(data = FUNC_data,
                      aes(x=plate, y=log(value+1), color=level_factor, fill = level_factor, shape = level_factor, 
                          group = level_factor)) + 
    geom_point() + 
    geom_line() + 
    theme_classic() +
    labs(y = paste0("log[value]"), x = NULL)+
    theme(plot.title = element_blank(),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          legend.text = element_text(size = 5),
          legend.title = element_text(size = 5),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank()) +
    scale_x_discrete(expand = c(0.1,0.1)) +
    scale_colour_manual(values = plot_colours,
                        labels = names(plot_colours)) +
    scale_fill_manual(values = plot_fill,
                      labels = names(plot_fill)) +
    scale_shape_manual(values = plot_shape,
                       labels = names(plot_shape)) +
    facet_wrap(~type, ncol = 2, scales = "free", dir = "h")
  
  #export as plotly
 ggplotly(FUNC_plot)
}


```

Control charts produced for each metabolite for each of the calibration and QC injections:

-   Peak area of target

-   peak area of SIL internal standard

-   response ratio

### Metabolite targets with internal standard

```{r Cal and QC control charts (metabolites with SIL), eval=TRUE, echo=TRUE, paged.print=FALSE, warning=FALSE, results='asis'}

#--------------------------------------------------------------------------------------------------------------------------- 
# application of function to data that does have a matched SIL in the data
#--------------------------------------------------------------------------------------------------------------------------- 
#re-order sil_template to put NA at bottom
mstr_lst$data$SIL_template <- mstr_lst$data$SIL_template[order(is.na(mstr_lst$data$SIL_template$SIL_standard)),]
#create empty rmd list for knit_child workaround
temp_rmd_list <- list()

# for those metabolites that have a linked SIL internal standard create a response ratio
for(idx_metabolite in mstr_lst$data$SIL_template$standard){
  SIL_used = mstr_lst$data$SIL_template$SIL_standard[mstr_lst$data$SIL_template$standard==idx_metabolite]
if(!is.na(SIL_used)){
  #create response ratio
   mstr_lst$data$response[[idx_metabolite]] <- mstr_lst$data$area %>%
     select(plate, name, type, all_of(c(idx_metabolite, SIL_used))) %>%
     add_column(std_conc = mstr_lst$data$std_conc[[idx_metabolite]], .before = idx_metabolite) %>%
     mutate_at(c("std_conc", idx_metabolite, SIL_used), as.numeric) %>%
     mutate(response = .[[idx_metabolite]]/.[[SIL_used]])
  
  #produce control chart
  mstr_lst$control_charts[[idx_metabolite]] <- CalQC_controlPlotR(
     FUNC_data = mstr_lst$data$response[[idx_metabolite]] %>%
       rename_at(idx_metabolite, ~paste0("area")) %>%
       rename_at(SIL_used, ~paste0("area_SIL")) %>%
       filter(type == "Standard" | type == "QC")
     )
  
#knitchild workaround to dynamically print hmtl widgets
  temp_plot <- combineWidgets(
    mstr_lst$control_charts[[idx_metabolite]],
    height = 750)
  
  #create temp rmd file using sink
  temp_rmd_path <- paste0(mstr_lst$proj_optns$proj_dir, idx_metabolite, ".rmd")
  temp_rmd_list[[idx_metabolite]] <- temp_rmd_path
  sink(file = temp_rmd_path)
  cat("  \n", "### ", idx_metabolite, "  \n", 
      "  \n", "##### ", " Internal standard used: ", paste0(SIL_used), "  \n",
      "```{r, echo=FALSE, warning=FALSE}", "  \n", 'temp_plot', "  \n", "```", "  \n", 
      sep = "")
  sink()

# ---------- knit using knit_child function
  # Knit the temporary RMD file
 cat(knitr::knit_child(temp_rmd_list[[idx_metabolite]],
  quiet = TRUE))

  # Delete the temporary RMD files
  file.remove(temp_rmd_list[[idx_metabolite]])
  }
  }

```

### Metabolite targets without internal standard

::: callout-note
## Note: the below metabolites do not have an internal standard selected in the template
:::

```{r Cal and QC control charts (metabolites without SIL), eval=TRUE, echo=TRUE, paged.print=FALSE, warning=FALSE, results='asis'}
#--------------------------------------------------------------------------------------------------------------------------- 
# application of function to data that does not have a matched SIL in the data
#--------------------------------------------------------------------------------------------------------------------------- 

for(idx_metabolite in mstr_lst$data$SIL_template$standard){
  SIL_used = mstr_lst$data$SIL_template$SIL_standard[mstr_lst$data$SIL_template$standard==idx_metabolite]
if(is.na(SIL_used)){
    #produce control chart
  mstr_lst$control_charts[[idx_metabolite]] <- CalQC_controlPlotR(
     FUNC_data = left_join(by="name",
                           mstr_lst$data$std_conc %>%
                             select(plate, name, type, all_of(idx_metabolite)) %>%
                             rename_at(idx_metabolite, ~paste0("std_conc")),
                           mstr_lst$data$area %>%
                             select(name, all_of(idx_metabolite)) %>%
                             rename_at(idx_metabolite, ~paste0("area"))) %>% 
       filter(type == "Standard" | type == "QC")
     )
  
 #knitchild workaround to dynamically print hmtl widgets
  temp_plot <- combineWidgets(
    mstr_lst$control_charts[[idx_metabolite]],
    height = 250)
  
  #create temp rmd file using sink
  temp_rmd_path <- paste0(mstr_lst$proj_optns$proj_dir, idx_metabolite, ".rmd")
  temp_rmd_list[[idx_metabolite]] <- temp_rmd_path
  sink(file = temp_rmd_path)
  cat("  \n", "### ", idx_metabolite, "  \n", 
      "  \n", "##### ", "No internal standard used", "  \n",
      "```{r, echo=FALSE, warning=FALSE}", "  \n", 'temp_plot', "  \n", "```", "  \n", 
      sep = "")
  sink()

# ---------- knit using knit_child function
  # Knit the temporary RMD file
  cat(knitr::knit_child(temp_rmd_list[[idx_metabolite]],
                        quiet = TRUE))

  # Delete the temporary RMD files
  file.remove(temp_rmd_list[[idx_metabolite]])
}}
```

## Calibration

```{r calibration functions, eval=TRUE, echo=TRUE, paged.print=FALSE, warning=FALSE, error=TRUE}
# Calibration functions: calibratR; calibrate_PlotR
#--------------------------------------------------------------------------------------------------------------------------- 
# calibratR
#--------------------------------------------------------------------------------------------------------------------------- 
calibratR <- function(FUNC_data,
                      FUNC_HEADER_cal,
                      FUNC_STRING_std,
                      FUNC_STRING_qc,
                      FUNC_STRING_sample,
                      FUNC_STRING_title){
  FUNC_list <- list(
    lmX_data = FUNC_data %>%
      filter(type == FUNC_STRING_std) %>%
      add_column("weights" = 1/(.[[FUNC_HEADER_cal]]^2))
    ) %>%
    list_modify(
    #build lm model (FUNC_HEADER_cal ~ std_conc, weighted by 1/x^2)
    lmX = lm(data = .$lmX_data,
             formula = paste0(FUNC_HEADER_cal, " ~ std_conc"),
             weights = weights)
    ) %>% list_modify(
      percent_dev = 100*(resid(.$lmX)/.$lmX_data[[FUNC_HEADER_cal]]), #calculate percentatge residuals
      fail_list = NULL, #create empty list for fail list
      cal_length = NULL #create empty list for cal length (# of cal points)
    )
  
  #run a while loop to assess calibration, and if necessary remove points and rebuild
  while((summary(FUNC_list$lmX)$adj.r.squared < 0.99 | 
        max(abs(FUNC_list$percent_dev)) > 25) &
        length(FUNC_list$percent_dev) > 5){
    max_fail_idx <- which.max(abs(as.numeric(FUNC_list$percent_dev)))
    FUNC_list$fail_list <- c(FUNC_list$fail_list, FUNC_list$lmX_data$std_conc[[max_fail_idx]])
    FUNC_list$lmX_data <- FUNC_list$lmX_data[-max_fail_idx, ]
    FUNC_list$lmX <- lm(data = FUNC_list$lmX_data,
                        formula = paste0(FUNC_HEADER_cal, " ~ std_conc"),
                        weights = weights)
    FUNC_list$cal_length <- length(FUNC_list$lmX_data$std_conc)
    FUNC_list$percent_dev <- 100*(resid(FUNC_list$lmX)/FUNC_list$lmX_data[[FUNC_HEADER_cal]])
  }
  
  #create tibble containing prediction data
  FUNC_list$lmX_pred_data <- FUNC_data %>%
      filter(!name %in% FUNC_list$lmX_data$name) %>%
      add_column("weights" = 1/(.[[FUNC_HEADER_cal]]^2))
  
  #back calculate conc from response for remaining data
  FUNC_list$lmX_pred_data$calc_conc <- 
    (FUNC_list$lmX_pred_data[[FUNC_HEADER_cal]] - FUNC_list$lmX$coefficients[1])/FUNC_list$lmX$coefficients[2]
  
  #evaluate QC performance
  FUNC_list$qc_summary <- FUNC_list$lmX_pred_data %>%
    filter(type == FUNC_STRING_qc) %>%
    add_column(residual = (.$std_conc/.$calc_conc)*100)
  #ad pass/fail column
  FUNC_list$qc_summary$pass <- TRUE
  FUNC_list$qc_summary$pass[which(abs(100-FUNC_list$qc_summary$residual) > 25)] <- FALSE
  
  #create results table
  FUNC_list$summary_tbl <- tibble(
    plate = FUNC_STRING_title,
    r2 = signif(summary(FUNC_list$lmX)$adj.r.squared, 4),
    intercept = signif(FUNC_list$lmX$coef[[1]],2),
    slope = signif(FUNC_list$lmX$coef[[2]], 2),
    cal_length = length(FUNC_list$percent_dev),
    cal_included = paste(FUNC_list$lmX_data$std_conc, collapse = "; "),
    cal_failed = paste(FUNC_list$fail_list, collapse = "; "),
    qc_pass = paste(FUNC_list$qc_summary$std_conc[which(FUNC_list$qc_summary$pass==TRUE)], collapse = "; "),
    qc_fail = paste(FUNC_list$qc_summary$std_conc[which(FUNC_list$qc_summary$pass==FALSE)], collapse = "; ")
  )
  
  #create calibration plot of calibrants
  #create plot_data
  FUNC_list$plot_data <- bind_rows(
  #pass stds [calibration data]
  FUNC_list$lmX$model %>% rename(conc = std_conc) %>% add_column(type = "std_pass", .before = 1),
  #failed standards
  FUNC_list$lmX_pred_data %>% 
    filter(type == FUNC_STRING_std) %>% 
    rename(conc = std_conc) %>%
    select(response, conc) %>%
    add_column(type = "std_fail"),
  #pass qc
  FUNC_list$lmX_pred_data %>% 
    filter(type == FUNC_STRING_qc) %>% 
    filter(name %in% (filter(FUNC_list$qc_summary, pass == TRUE))[["name"]]) %>%
    rename(conc = std_conc) %>%
    select(response, conc) %>%
    add_column(type = "qc_pass"),
  #fail qc
  FUNC_list$lmX_pred_data %>% 
    filter(type == FUNC_STRING_qc) %>% 
    filter(name %in% (filter(FUNC_list$qc_summary, pass == FALSE))[["name"]]) %>%
    rename(conc = std_conc) %>%
    select(response, conc) %>%
    add_column(type = "qc_fail"),
  #Analyte
  FUNC_list$lmX_pred_data %>% 
    filter(type == FUNC_STRING_sample) %>% 
    rename(conc = calc_conc) %>%
    select(response, conc) %>%
    add_column(type = "study_sample")
) %>% as_tibble() 

  FUNC_list$plot_data$type <- FUNC_list$plot_data$type %>%
    factor(levels = c("study_sample", "std_pass", "qc_pass", "std_fail", "qc_fail"), 
                         ordered = TRUE)

   FUNC_list
  }

#--------------------------------------------------------------------------------------------------------------------------- 
# calibrate_plotR function
#--------------------------------------------------------------------------------------------------------------------------- 
calibrate_plotR <- function(FUNC_data,
                            FUNC_lm_color){
  #set common colours, sizes and shapes
  group_colours <- c("std_pass" = "darkgreen", "std_fail" = "red", "qc_pass" = "darkgreen", "qc_fail" = "red", "study_sample" = "black")
group_sizes <- c("std_pass" = 2.5, "std_fail" = 2.5, "qc_pass" = 2.5, "qc_fail" = 2.5, "study_sample" = 1)
group_shape <- c("std_pass" = 25, "std_fail" = 25, "qc_pass" = 21, "qc_fail" = 21, "study_sample" = 3)
lm_color <-


#create plot
 FUNC_plot <- ggplot(data = FUNC_data,
                  aes(x=conc, y=response)) +
  geom_point(aes(color=type, shape=type, size=type)) +
  scale_size_manual(values = group_sizes, guide = "none") +
  scale_shape_manual(values = group_shape,
                     labels = c("qc_fail", "qc_pass", "std_fail", "std_pass", "study_sample")) +
  scale_color_manual(values = group_colours,
                     labels = c("qc_fail", "qc_pass", "std_fail", "std_pass", "study_sample")) +
  theme_bw() +
  theme(plot.title = element_blank(),
        axis.title = element_text(size = 5),
        axis.text = element_text(size = 5),
        legend.text = element_text(size = 5),
        legend.title = element_text(size = 5)) +
  facet_wrap(~plate_id, ncol = 3, labeller = labeller(plate_id = label_wrap_gen(width = 30, multi_line = TRUE))) +
  theme(strip.placement = "outside",
        strip.background = element_blank(),
        panel.spacing.y = unit(2, "lines")) +
  stat_smooth(data = ~filter(.x, type == "std_pass"),
              geom = "line", alpha = 0.5, size = 1,method = "lm",
              formula = y ~ x, fullrange = TRUE, se = FALSE, color = FUNC_lm_color,
              mapping = aes(weight = `(weights)`)
              ) 
 #convert to plotly object
 ggplotly(FUNC_plot)
}

```

Following calibration, metabolites are assigned either:

-   Concentration values: metabolite has an external calibration dilution series using response values created by calculating a ratio with the peak area of a matched (or surrogate) stable isotope labelled internal standard. Metabolites have passed quality control assessment consisting of:

    -   r2 value \> 0.99

    -   minimum of 6 calibration points with a residual deviation \<25% from expected concentration

    -   minimum of 2 analytical QC with a residual deviation \<25% from expected concentration

-   Response values: metabolite has an external calibration dilution series using response values created by calculating a ratio with the peak area of a matched (or surrogate) stable isotope labelled internal standard. Metabolites have failed quality control assessment described above.

-   Peak area: metabolite does not have an external calibration dilution series and does not use a stable isotope labelled internal standard.

```{r apply calibration functions to data, eval=TRUE, echo=TRUE, paged.print=FALSE, warning=FALSE}
# application of calibration functions to data
#--------------------------------------------------------------------------------------------------------------------------- 
#Run loop to perform calibration for each target analyte
#--------------------------------------------------------------------------------------------------------------------------- 
#set tibble for calibration data out
mstr_lst$data$calib <- mstr_lst$data$area %>%
  select(plate, name, type) %>%
  filter(type == "Analyte")

for(idx_metabolite in mstr_lst$data$SIL_template$standard){
  #create calibration output list()
  temp_lst <- lst(
  #find SIL used from tempalte
  SIL_used = mstr_lst$data$SIL_template$SIL_standard[which(mstr_lst$data$SIL_template$standard == idx_metabolite)],
  all_plates = lst(
    plot = lst(data = NULL,
               calib = NULL,
               control_chart = NULL),
    summary = NULL,
    lmX_data = NULL,
    lmX_pred_data = NULL
  ))

  if(!is.na(temp_lst$SIL_used)){
  #create response ratio
   mstr_lst$data$response[[idx_metabolite]] <- mstr_lst$data$area %>%
     select(plate, name, type, all_of(c(idx_metabolite, temp_lst$SIL_used))) %>%
     add_column(std_conc = mstr_lst$data$std_conc[[idx_metabolite]], .before = idx_metabolite) %>%
     mutate_at(c("std_conc", idx_metabolite, temp_lst$SIL_used), as.numeric) %>%
     mutate(response = .[[idx_metabolite]]/.[[temp_lst$SIL_used]])
  
   #perform the below for each plate independently
   for(idx_plate in 1:length(mstr_lst$data$plate_lst)){
   #run calibratR function
  temp_lst[[paste0("plate_", idx_plate)]] <- calibratR(
    FUNC_data = mstr_lst$data$response[[idx_metabolite]] %>%
      filter(plate == unique(mstr_lst$data$response[[idx_metabolite]]$plate)[idx_plate]),
    FUNC_HEADER_cal = "response",
    FUNC_STRING_std = "Standard",
    FUNC_STRING_qc = "QC",
    FUNC_STRING_sample = "Analyte",
    FUNC_STRING_title = mstr_lst$data$response[[idx_metabolite]]$plate[idx_plate]
    )
  
  #append to all_plates
  temp_lst$all_plates$plots[[idx_plate]] <-
    temp_lst[[paste0("plate_", idx_plate)]]$cal_plot
  
   temp_lst$all_plates$summary <- temp_lst$all_plates$summary %>%
     bind_rows(temp_lst[[paste0("plate_", idx_plate)]]$summary_tbl)
   
  temp_lst$all_plates$lmX_data <-
     temp_lst$all_plates$lmX_data %>%
     bind_rows(temp_lst[[paste0("plate_", idx_plate)]]$lmX_data)
   
   temp_lst$all_plates$lmX_pred_data <-
     temp_lst$all_plates$lmX_pred_data %>%
     bind_rows(temp_lst[[paste0("plate_", idx_plate)]]$lmX_pred_data)
   
   #create combined data for plotting with facet wrap
    temp_lst$all_plates$plot$data <- bind_rows(
      temp_lst$all_plates$plot$data,
      temp_lst[[paste0("plate_", idx_plate)]]$plot_data %>%
        add_column(plate_id = paste0(mstr_lst$data$response[[idx_metabolite]]$plate[idx_plate], "; ",
                                     "r2=", temp_lst$all_plates$summary$r2[idx_plate],"; ",
                                     "slope=", temp_lst$all_plates$summary$slope[idx_plate],
                                     "; int=", temp_lst$all_plates$summary$intercept[idx_plate]))
    )}
   

   #if passes QC append concentration data to CONC
   if(min(temp_lst$all_plates$summary$r2) > 0.99){
     # produce calibration plot with green lm line
   temp_lst$all_plates$plot$calib <- calibrate_plotR(FUNC_data = temp_lst$all_plates$plot$data,
                                                     FUNC_lm_color = "darkgreen")
     
   #append to masterlist with _CONC tag
   mstr_lst$data$calib <- mstr_lst$data$calib %>%
     left_join(., select(temp_lst$all_plates$lmX_pred_data, name, all_of(idx_metabolite)), 
               by="name") %>%
     rename_at(idx_metabolite, list(~paste0(idx_metabolite, "_CONC")))
   
   #create record in calibration summary table
   mstr_lst$tbls$calib_summary <- mstr_lst$tbls$calib_summary %>% 
     bind_rows(
       tibble(metabolite = idx_metabolite, data_type = "conc", reason = "pass calibration"))
   
   #append temp_list to mstr_lst$calib$conc
   mstr_lst$calib$conc[[idx_metabolite]] <- temp_lst
     
   } else {
     #if metabolite fails quantification QC, keep and append response values to mstr_lst
     
        # produce calibration plot with green lm line
   temp_lst$all_plates$plot$calib <- calibrate_plotR(FUNC_data = temp_lst$all_plates$plot$data,
                                                     FUNC_lm_color = "darkred")
     
   #append to masterlist with _RESPONSE tag
       mstr_lst$data$calib <- mstr_lst$data$calib %>%
     left_join(., select(mstr_lst$data$response[[idx_metabolite]], name, response),
               by = "name") %>%
     rename_at("response", list(~paste0(idx_metabolite, "_RESPONSE")))
       
       #create record in calibration summary table
   mstr_lst$tbls$calib_summary <- mstr_lst$tbls$calib_summary %>% 
     bind_rows(
       tibble(metabolite = idx_metabolite, data_type = "area", reason = "failed calibration"))
   
    #append temp_list to mstr_lst$calib$conc
   mstr_lst$calib$response[[idx_metabolite]] <- temp_lst
  
   } #end of response if
   
  }else{
     
    #if there is no IS only keep and append areas to mstr_lst
   mstr_lst$data$calib <- mstr_lst$data$calib %>%
     left_join(., select(mstr_lst$data$area, name, all_of(idx_metabolite)), by = "name") %>%
     rename_at(idx_metabolite, list(~paste0(idx_metabolite, "_AREA")))
    
   #create record in calibration summary table
   mstr_lst$tbls$calib_summary <- mstr_lst$tbls$calib_summary %>% 
     bind_rows(
       tibble(metabolite = idx_metabolite, data_type = "area", reason = "no IS in template"))
      }
}

mstr_lst$tbls$calib_summary %>%
        kbl(align = "c", booktabs = TRUE, longtable = TRUE) %>%
        kable_minimal("hover") %>%
        kable_styling(font_size = 10) %>%
        scroll_box(height = "500px")
```

### Concentration

```{r calibration reporting, eval=TRUE, echo=TRUE, paged.print=FALSE, warning=FALSE, results='asis'}

# -------------- create combined widget of cal plots and summary table and knit to report
  #make empty list in master list
mstr_lst$report <- list(
  conc = list(),
  response = list(),
  test = list()
)

#create empty rmd list for knit_child workaround
temp_rmd_list <- list()

#run loop for each metabolite that passes QC
for(idx_metabolite in names(mstr_lst$calib$conc)){
  plot_row_freq <- ceiling(length(unique(mstr_lst$calib$conc[[idx_metabolite]]$all_plates$summary$plate))/3)
  mstr_lst$report$conc[[idx_metabolite]] <- list(
  plot = combineWidgets(
    mstr_lst$calib$conc[[idx_metabolite]]$all_plates$plot$calib, # calib plots
    height = plot_row_freq * 400, width = 800, rowsize = 1, ncol = 1),
  tble = combineWidgets(
    mstr_lst$calib$conc[[idx_metabolite]]$all_plates$summary %>%
      kbl(align = "c", booktabs = TRUE, longtable = TRUE) %>%
      kable_minimal("hover") %>%
      kable_styling(font_size = 10) %>%
      scroll_box(width = "750px"),
    height = (plot_row_freq+1) * 115, width = 800, rowsize = 1, ncol = 1))
  
# ----------- Create temp rmd file as a work around for rendering dynamic html widgets from a loop
  temp_rmd_path <- paste0(mstr_lst$proj_optns$proj_dir, idx_metabolite, ".rmd")
  temp_rmd_list[[idx_metabolite]] <- temp_rmd_path
  sink(file = temp_rmd_path)
  cat("  \n", "### ", idx_metabolite, "  \n", "```{r, echo=FALSE, warning=FALSE}", "  \n",
      'mstr_lst$report$conc[[idx_metabolite]]$plot', "  \n", 
      'mstr_lst$report$conc[[idx_metabolite]]$tble', "  \n", 
      "```", "  \n", sep = "")
  sink()

# ---------- knit using knit_child function
  # Knit the temporary RMD file
  cat(knitr::knit_child(temp_rmd_list[[idx_metabolite]],
                        quiet = TRUE))

  # Delete the temporary RMD files
  file.remove(temp_rmd_list[[idx_metabolite]])
}
```

### Response

```{r response reporting, eval=TRUE, echo=TRUE, paged.print=FALSE, warning=FALSE, results='asis'}

# -------------- create combined widget of cal plots and summary table and knit to report

#create empty rmd list for knit_child workaround
temp_rmd_list <- list()

#run loop for each metabolite that passes QC
for(idx_metabolite in names(mstr_lst$calib$response)){
  plot_row_freq <- ceiling(length(unique(mstr_lst$calib$response[[idx_metabolite]]$all_plates$summary$plate))/3)
  mstr_lst$report$response[[idx_metabolite]] <- list(
  plot = combineWidgets(
    mstr_lst$calib$response[[idx_metabolite]]$all_plates$plot$calib, # calib plots
    height = plot_row_freq * 400, width = 800, rowsize = 1, ncol = 1),
  tble = combineWidgets(
    mstr_lst$calib$response[[idx_metabolite]]$all_plates$summary %>%
      kbl(align = "c", booktabs = TRUE, longtable = TRUE) %>%
      kable_minimal("hover") %>%
      kable_styling(font_size = 10) %>%
      scroll_box(width = "750px"),
    height = (plot_row_freq+1) * 115, width = 800, rowsize = 1, ncol = 1))
  
# ----------- Create temp rmd file as a work around for rendering dynamic html widgets from a loop
  
  temp_rmd_path <- paste0(mstr_lst$proj_optns$proj_dir, idx_metabolite, ".rmd")
  temp_rmd_list[[idx_metabolite]] <- temp_rmd_path
  sink(file = temp_rmd_path)
  cat("  \n", "### ", idx_metabolite, "  \n", "```{r, echo=FALSE, warning=FALSE}", "  \n",
      'mstr_lst$report$response[[idx_metabolite]]$plot', "  \n", 
      'mstr_lst$report$response[[idx_metabolite]]$tble', "  \n", 
      "```", "  \n", sep = "")
  sink()

# ---------- knit using knit_child function
  # Knit the temporary RMD file
  cat(knitr::knit_child(temp_rmd_list[[idx_metabolite]],
                        quiet = TRUE))

  # Delete the temporary RMD files
  file.remove(temp_rmd_list[[idx_metabolite]])
}
```

### Control chart of LTR performance

```{r LTR_control_plotR function to control chart LTR analysis, eval = TRUE, results='asis'}

#------------- write FUNCTION to create LTR control chart
LTR_control_plotR <- function(FUNC_data,
                          FUNC_plot_header,
                          FUNC_y_title){
  
FUNC_data <- FUNC_data %>%
    #crop plate order
    add_column(
      run_order = lapply(str_split(FUNC_data$name, "_"), function(x) tail(x, n=1)) %>% unlist() %>% as.numeric()
    ) %>%
    arrange(plate, run_order) %>% 
    add_column(sample_idx = factor(1:nrow(.), ordered = TRUE)) %>%
    rename_at(FUNC_plot_header, list(~paste0("y_data")))
  
  #find LTRs
  FUNC_data$type[grep("LTR", FUNC_data$name)] <- "LTR"
  
  #find plate IDX for plate vlines
  plate_idx <- NULL
  for(idx_plate in unique(FUNC_data$plate)){
    plate_idx <- c(plate_idx,
                   max(which(FUNC_data$plate == idx_plate)))
  }
  plate_idx <- (plate_idx[1:length(plate_idx)-1])+0.5
  
  #find values for hlines
  #median LTR conc
  LTR_median = (FUNC_data %>% filter(type == "LTR"))[["y_data"]] %>% median()
  #LTR std.dev 
  LTR_sd = (FUNC_data %>% filter(type == "LTR"))[["y_data"]] %>% sd()
  #calcluate 1x and 2x sd range
  LTR_1sd_range = c((LTR_median - LTR_sd), (LTR_median + LTR_sd))
  LTR_2sd_range = c((LTR_median - LTR_sd*2), (LTR_median + LTR_sd*2))
  
  #create plot
  FUNC_plot <- ggplot(data = FUNC_data,
                      aes(x=sample_idx, y=log(y_data+1), fill = type, shape=type, size=type)) +
    geom_point(color = "black") +
    geom_vline(xintercept = plate_idx) +
    geom_hline(yintercept = log(LTR_median+1), color = "orange") +
    geom_hline(yintercept = log(LTR_1sd_range+1), color = "orange", linetype = "dashed") +
    geom_hline(yintercept = log(LTR_2sd_range+1), color = "orange", linetype = "dotted") +
    theme_classic() +
    labs(y = paste0("log(", FUNC_y_title, ")"))+
    theme(plot.title = element_blank(),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          legend.text = element_text(size = 5),
          legend.title = element_text(size = 5),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank()) +
    scale_x_discrete(expand = c(0.02,0.02)) +
    scale_fill_manual(values=c("black", "orange")) +
    scale_shape_manual(values = c(3, 21)) +
    scale_size_manual(values = c(1,2.5))
  
  ggplotly(FUNC_plot)  
 
}


#------------- apply FUNCTION to data create LTR control chart for each metabolite

mstr_lst$ltr <- list(
  control_charts = list()
)
  
for(idx_metabolite in mstr_lst$tbls$calib_summary$metabolite){
  if(mstr_lst$tbls$calib_summary$data_type[which(mstr_lst$tbls$calib_summary$metabolite == idx_metabolite)] == "conc"){
#create control chart - conc
   mstr_lst$ltr$control_charts[[idx_metabolite]] <- LTR_control_plotR(
     FUNC_data = mstr_lst$calib$conc[[idx_metabolite]]$all_plates$lmX_pred_data %>% 
       filter(type == "Analyte"),
     FUNC_plot_header = "calc_conc",
     FUNC_y_title = "concentration")
  }
  
  if(mstr_lst$tbls$calib_summary$data_type[which(mstr_lst$tbls$calib_summary$metabolite == idx_metabolite)] == "response"){
#create control chart - response
   mstr_lst$ltr$control_charts[[idx_metabolite]] <- LTR_control_plotR(
     FUNC_data = mstr_lst$calib$response[[idx_metabolite]]$all_plates$lmX_pred_data %>% 
       filter(type == "Analyte"),
     FUNC_plot_header = "response",
     FUNC_y_title = "response")
  }
  
    if(mstr_lst$tbls$calib_summary$data_type[which(mstr_lst$tbls$calib_summary$metabolite == idx_metabolite)] == "area"){
#create control chart - response
   mstr_lst$ltr$control_charts[[idx_metabolite]] <- LTR_control_plotR(
     FUNC_data = mstr_lst$data$area %>%
       filter(type == "Analyte") %>%
       rename_at(idx_metabolite, ~paste0("area")),
     FUNC_plot_header = "area",
     FUNC_y_title = "area")
  }

# ----------- Create temp rmd file as a work around for rendering dynamic html widgets from a loop
  temp_rmd_path <- paste0(mstr_lst$proj_optns$proj_dir, idx_metabolite, ".rmd")
  temp_rmd_list[[idx_metabolite]] <- temp_rmd_path
  sink(file = temp_rmd_path)
  cat("  \n", "### ", idx_metabolite, "  \n", "```{r, echo=FALSE, warning=FALSE}", "  \n",
      'mstr_lst$ltr$control_charts[[idx_metabolite]]', "  \n", 
      "```", "  \n", sep = "")
  sink()

# ---------- knit using knit_child function
  # Knit the temporary RMD file
  cat(knitr::knit_child(temp_rmd_list[[idx_metabolite]],
                        quiet = TRUE))

  # Delete the temporary RMD files
  file.remove(temp_rmd_list[[idx_metabolite]])
  
}
```

### LTR Relative Standard Deviation performance

Metabolites were filtered if the %RSD was \> 30% across the project

```{r evaluate LTR performance, eval=TRUE, echo=TRUE, paged.print=FALSE, warning=FALSE, results='asis'}

mstr_lst$ltr$rsd <- list(data = NULL,
                         plot = NULL)

for(idx_metabolite in names(select(mstr_lst$data$calib, - plate, -name, -type))){
  temp_ltr_data <- (mstr_lst$data$calib %>%
    filter(grepl("LTR", mstr_lst$data$calib$name)))[[idx_metabolite]]
  ltr_missing_values <- which(is.na(temp_ltr_data))
  ltr_perc_missing_values <- (length(ltr_missing_values)/length(temp_ltr_data))*100
  ltr_mean <- mean(temp_ltr_data)
  ltr_sd <- sd(temp_ltr_data)
  ltr_rsd <- (ltr_sd*100)/ltr_mean
  
  mstr_lst$ltr$rsd$data <- mstr_lst$ltr$rsd$data %>%
    bind_rows(
      tibble("metabolite" = idx_metabolite,
             "rsd" = ltr_rsd)
    )}

mstr_lst$ltr$rsd$data <- mstr_lst$ltr$rsd$data %>%
  arrange(rsd) %>%
  add_column(
    metabolite_factor = factor(.$metabolite, levels = c(.$metabolite), ordered= TRUE)
  )

#create plot
  mstr_lst$ltr$rsd$plot <- ggplot(data = mstr_lst$ltr$rsd$data,
                      aes(x=metabolite_factor, y=rsd)) +
    geom_point(color = "black") +
    geom_hline(yintercept = 20, color = "orange") +
    geom_hline(yintercept = 30, color = "orange", linetype = "dashed") +
    theme_bw() +
    labs(y = paste0("%RSD"))+
    theme(plot.title = element_blank(),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          legend.text = element_text(size = 5),
          legend.title = element_text(size = 5),
          axis.text.x = element_text(angle = 90),
          axis.ticks.x = element_blank()) +
    scale_x_discrete(expand = c(0.02,0.02)) 

  combineWidgets(ggplotly(mstr_lst$ltr$rsd$plot),
              height = 500, width = 600, rowsize = 1, ncol = 1)
  
  #filter data to exclude data that failed RSD filter
  mstr_lst$data$calib_ltr_filtered <- mstr_lst$data$calib %>%
    select(plate, name, type, 
           all_of(c(mstr_lst$ltr$rsd$data$metabolite[which(mstr_lst$ltr$rsd$data$rsd < 30)])))
  
  mstr_lst$ltr$rsd$data$excluded <- FALSE
  mstr_lst$ltr$rsd$data$excluded[which(mstr_lst$ltr$rsd$data$rsd >30)] <- TRUE
  
#print table in report
mstr_lst$ltr$rsd$data %>%
  select(-metabolite_factor) %>%
  kbl(align = "c", booktabs = TRUE, longtable = TRUE) %>%
  kable_minimal("hover") %>%
  kable_styling(font_size = 12) %>%
  scroll_box(height = "250px") %>% print()
  
```

## Missing value overview

-   metabolites are assessed for % missing values (0 or NA)

-   metabolites with \>50% of missing values are removed from analysis

```{r missing value overview, eval = TRUE, echo = TRUE, results='asis'}

mstr_lst$tbls$missing_val <- NULL

#run missing value search for each dataset
for(idx_metabolite in names(select(mstr_lst$data$calib_ltr_filtered, - plate, -name, -type))){
  mstr_lst$tbls$missing_val <- mstr_lst$tbls$missing_val %>%
    bind_rows(
      tibble(metabolite = idx_metabolite,
             percent_missing_values = 
               (length(which(mstr_lst$data$calib_ltr_filtered[[idx_metabolite]]==0)) + 
                  length(which(is.na(mstr_lst$data$calib_ltr_filtered[[idx_metabolite]])))/
                  length(mstr_lst$data$calib_ltr_filtered[[idx_metabolite]]))*100))
}

#remove metabolite with >50% missing values
#filter data to exclude data that failed RSD filter
  mstr_lst$data$calib_ltr_mv_filtered <- mstr_lst$data$calib_ltr_filtered %>%
    select(plate, name, type, 
           all_of(c(mstr_lst$tbls$missing_val$metabolite[which(mstr_lst$tbls$missing_val$percent_missing_values < 50)])))
  
  mstr_lst$tbls$missing_val$excluded <- FALSE
  mstr_lst$tbls$missing_val$excluded[which(mstr_lst$tbls$missing_val$percent_missing_values >50)] <- TRUE
  
#print table in report
mstr_lst$tbls$missing_val %>%
  kbl(align = "c", booktabs = TRUE, longtable = TRUE) %>%
  kable_minimal("hover") %>%
  kable_styling(font_size = 12) %>%
  scroll_box(height="250px") %>% print()
```

## Principal Component Analysis (PCA) of data

-   Principal Component Analysis (PCA) was conducted to check the quality of the data. PCA is an unsupervised model (i.e. no prior group information is supplied to the model, labelling and colours applied after the model construction). This allows for observations on the quality of the dataset

-   Patterns in the data between samples can also be observed - this may be as a result of either biological or analytical differences - e.g. differences in sample collection, handling or storage

```{r PCA function, eval=TRUE, echo=TRUE, paged.print=FALSE, warning=FALSE, error=TRUE, results='asis'}

# -------------------------
# write PCA function
# -------------------------

lgw_rPCA <- function(FUNC_data, 
                    FUNC_metabolite_list, 
                    FUNC_HEADER_colour_by, 
                    FUNC_HEADER_plot_label, 
                    FUNC_OPTION_scaling,
                    FUNC_OPTION_log_data,
                    FUNC_OPTION_plot_colours){
  
  pca_output <- list()
  
  #create data matrix for PCA
  pca_x <- FUNC_data %>%  select(all_of(FUNC_metabolite_list)) %>% as.matrix() 
  
  #create PCA model
  pca_output$pca_model <- ropls::opls(x = pca_x,
                                      y = NULL,
                                      algoC = "nipals",
                                      predI = 2,
                                      crossvalI	= 5,
                                      log10L = FUNC_OPTION_log_data,
                                      scaleC = FUNC_OPTION_scaling,
                                      subset = NULL,
                                      fig.pdfC = 'none',
                                      info.txtC = 'none')
  
  # extract scores values for plotting in plot_ly
  plotly_scores_data <- pca_output$pca_model@scoreMN %>% as_tibble(rownames = "sample_idx") %>%
    add_column(type = FUNC_data[[FUNC_HEADER_colour_by]],
               name = FUNC_data[[FUNC_HEADER_plot_label]])
  
  plotly_scores_data$type <- "Sample"
  plotly_scores_data$type[grep("LTR", plotly_scores_data$name)] <- "LTR"
  
  pca_output$plot_scores <- ggplot(data = plotly_scores_data,
                      aes(x=p1, y=p2, fill = type, color=type, shape= type, size = type)) +
    geom_point() +
    labs(title=paste0(
      "samples: ", pca_output$pca_model@descriptionMC[,1][["samples"]],
      ", metabolites: ", pca_output$pca_model@descriptionMC[,1][["X_variables"]])) +
    theme_bw() +
    theme(plot.title = element_text(size=10),
          axis.title = element_text(size = 10),
          axis.text = element_text(size = 10),
          legend.text = element_text(size = 10),
          legend.title = element_text(size = 10),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank()) +
    scale_fill_manual(values=c("orange", "black")) +
     scale_color_manual(values=c("black", "black")) +
     scale_shape_manual(values = c(21,3)) +
    scale_size_manual(values = c(2.5, 1))
  
  ggplotly(pca_output$plot_scores)
}

#---------- apply PCA scores function

cat("### ", "PCA scores plot")

mstr_lst$ltr$pca <- lgw_rPCA(FUNC_data = mstr_lst$data$calib_ltr_mv_filtered,
                             FUNC_metabolite_list = mstr_lst$data$calib_ltr_mv_filtered %>%
                               select(-plate,-name, -type) %>% names(),
                             FUNC_HEADER_colour_by = "type",
                             FUNC_HEADER_plot_label = "name",
                             FUNC_OPTION_log_data = TRUE,
                             FUNC_OPTION_scaling = "pareto",
                             FUNC_OPTION_plot_colours = c("black", "orange")
                             )

combineWidgets(mstr_lst$ltr$pca,
              height = 600, width = 600, rowsize = 1, ncol = 1)

```
