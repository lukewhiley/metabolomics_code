---
title: Metabolomics data QC
format:
  html:
    code-fold: true
    code-tools: true
    df-print: paged
    toc: true
    toc-depth: 5
    self-contained: true
editor: visual
theme: cosmo
---

<!--# Quarto notebook for metabolomics data quality control -->\
<!--# Notebook will perform the following tasks: -->

<!--# import data that has been exported from processing software --> \
<!--# create calibration, QC data, filter data, report data-->

<!--# Notebook instructions: -->\
<!--# Enter user options in chunk 1 -->\
<!--# project folder must be set up as parent_directory/data-->\
<!--# default data type: import = .txt; export = .csv -->

<!--# required packages: 'tidyverse', 'janitor', 'qualV', 'kableExtra' -->

```{r notebook instructions and load packages, eval=TRUE, echo=FALSE}

# CSV DATA FILES MUST CONTAIN THE FOLLOWING COLUMN HEADERS AS A MINIMUM:
  # "sample_idx" - numeric column containing numeric index of sample location
  # "sample_name" - column containing string descriptor of sample file name
  # "sample_id" - column containing string descriptor of sample id
  # "sample_class" - column containing string descriptor of sample class
  # "sample_type" - column containing "sample" or "qc" string
  # "sample_batch" - batch or plate number for batch correction (if required)

  # Column headers should contain metabolite or feature names: 
    #e.g. CE(14:0) or TRYPTOPHAN or 2.86_180.0882m/z etc

#### load packages
package_list <- c('tidyverse', 'janitor', 'qualV', 'kableExtra')

for(idx_package in package_list){
  if(length(which(row.names(installed.packages()) == idx_package)) > 0){
    suppressMessages(require(package = idx_package,
                             character.only = TRUE))
  } else {
    paste0(idx_package, " is not installed. Please install ", idx_package, " before continuing.") %>% print()
  }
}


```

<!--# USER INPUT HERE -->

## Project set up and data import summary

```{r user setup; project structure; load packages, eval=TRUE, echo=TRUE}

#USER INPUT REQUIRED BELOW
mstr_lst <- list(
  proj_optns = list(
    proj_name = "QC testR; Tryptophan", #name of project
    usr_name = "LGW", #user of project
    proj_dir = "/Users/lukegraywhiley/Downloads/temp_data/test_qc/",
    proj_data_subdir = "data", # sub directory contatining export data from TargetLynx
    data_type = ".txt", # import flie type [.txt as default]
    keep_header = c("area") # header to keep [e.g c("response", "conc", "area") etc]
  )) %>% list_modify(
    
  ##----------- set project structure
  # NO USER INPUTE REQUIRED BELOW THIS LINE
  data = list(
    imprt_lst = list.files(paste0(.$proj_optns$proj_dir, .$proj_optns$proj_data_subdir), full.names = TRUE),
    imprt_lst_crop = list.files(paste0(.$proj_optns$proj_dir, .$proj_optns$proj_data_subdir), full.names = FALSE),
    std_conc = list(),
    area = list()),
  tbls = list(
    imprt_tbl = list())
)

cat(paste0("Project: ", mstr_lst$proj_optns$proj_name)); cat(paste0("Author: ", mstr_lst$proj_optns$usr_name))
```

<!--# automated from this point forwards-->

```{r load packages and flip data, eval=TRUE, echo=TRUE, paged.print=TRUE, warning=FALSE, results='asis'}

#--------- write flippR function
#read in data, set names, clean names, list metabolite element, filter blank space, spread data
targetlynx_flippR <- function(FUNC_txt_file_path,
                              FUNC_keep_hdr){
  list(data = read.delim(file = paste(FUNC_txt_file_path), sep = "\t",header=FALSE) %>% as_tibble() %>%
         set_names(., .[which(. == "Name", arr.ind=TRUE)[1,1],]) %>% clean_names()) %>%
    list_modify(metabolites = (unique(.$data$x[grep("Compound", .$data$x)]) %>% .[-grep("Report", .)] %>% sub(".*:  ", "", .)),
                filtered_data = .$data %>% filter(name != "" & name != "Name")) %>%
    list_modify(spread_data = (add_column(.$filtered_data, 
                                          metabolite = rep(.$metabolites, each = length(unique(.$filtered_data$name))))) %>%
                  select(name, type, metabolite,  all_of(FUNC_keep_hdr)) %>% 
                  spread(key = metabolite, value = all_of(FUNC_keep_hdr))) %>% .[["spread_data"]]
  }

#--------- run flippR function
#run flippR function and keep area and std_concs
for(idx_file in 1:length(mstr_lst$data$imprt_lst)){
  mstr_lst$data[["std_conc"]] <- mstr_lst$data[["std_conc"]] %>%
    bind_rows(targetlynx_flippR(FUNC_txt_file_path = mstr_lst$data$imprt_lst[idx_file], FUNC_keep_hdr = "std_conc") %>%
                add_column(plate = rep(mstr_lst$data$imprt_lst_crop[idx_file], nrow(.)), .before = 1))
 mstr_lst$data[["area"]] <- mstr_lst$data[["area"]] %>%
    bind_rows(targetlynx_flippR(FUNC_txt_file_path = mstr_lst$data$imprt_lst[idx_file], FUNC_keep_hdr = "area") %>%
                add_column(plate = rep(mstr_lst$data$imprt_lst_crop[idx_file], nrow(.)), .before = 1))

 #create summary table for report printing
mstr_lst$tbls[["imprt_tbl"]] <- bind_rows(
  mstr_lst$tbls[["imprt_tbl"]],
  bind_cols(plate = mstr_lst$data$imprt_lst_crop[idx_file],
            standards = nrow(
              mstr_lst$data$std_conc %>% filter(plate == mstr_lst$data$imprt_lst_crop[idx_file] & type == "Standard")),
            qc = nrow(
              mstr_lst$data$std_conc %>% filter(plate == mstr_lst$data$imprt_lst_crop[idx_file] & type == "QC")),
            samples = nrow(
              mstr_lst$data$std_conc %>% filter(plate == mstr_lst$data$imprt_lst_crop[idx_file] & type == "Analyte")),
            blanks = nrow(
              mstr_lst$data$std_conc %>% filter(plate == mstr_lst$data$imprt_lst_crop[idx_file] & type == "Blank")),
            features = ncol(mstr_lst$data$std_conc)-2
            ))
}
   
mstr_lst$tbls$imprt_tbl <- mstr_lst$tbls$imprt_tbl %>%
  bind_rows(tibble(
    plate = "total", standards = sum(.$standards), qc = sum(.$qc), samples = sum(.$samples), 
    blanks = sum(.$blanks), features = sum(.$features))
  )

cat("data imported:")
mstr_lst$tbls$imprt_tbl %>%
  kbl(align = "c", booktabs = TRUE, longtable = TRUE) %>%
  kable_minimal("hover") %>%
  kable_styling(font_size = 12) %>%
  scroll_box() %>% print()



```

## Perform calibration

```{r, calibration of data, eval=TRUE, echo=TRUE, paged.print=TRUE, warning=FALSE, results='asis'}

tryptophan <- lst(
  area = mstr_lst$data$area %>% clean_names %>% select(plate,  name, type, tryptophan, sil_tryptophan_pos_d5),
  std_conc = mstr_lst$data$std_conc %>% clean_names %>% select(plate,  name, type, tryptophan, sil_tryptophan_pos_d5)
) %>%
  list_modify(
    response = add_column(
      .$area %>%
      add_column(response = as.numeric(.$tryptophan)/as.numeric(.$sil_tryptophan_pos_d5)) %>%
      select(-c(tryptophan, sil_tryptophan_pos_d5)),
      std_conc = .$std_conc$tryptophan %>% as.numeric()
      ) %>% add_column(
        weights = 1/(.$response^2)),
    plate_list = unique(.$area$plate)
  ) %>%
  list_modify(
    to_plot = filter(.$response, type == "Standard" & plate == .$plate_list[1])
  )

x = lm(data = tryptophan$to_plot,
   formula = response~std_conc,
   weights = weights)
  

percent_dev = 100*(resid(x)/tryptophan$to_plot$response)

percent_failed <- which(abs(as.numeric(percent_dev)) >20)

if(length(percent_failed) > 1){
  max_fail = which.max(abs(as.numeric(percent_dev)))
  to_plot2 <- tryptophan$to_plot [-max_fail, ]
}


x = lm(data = to_plot2,
   formula = response~std_conc,
   weights = weights)

percent_dev_2 = 100*(resid(x)/to_plot2$response)


```

```{r load packages and set up project structure, eval=FALSE, echo=TRUE, paged.print=TRUE, warning=FALSE, results = 'asis'}

#### load packages
package_list <- c('tidyverse', 'janitor', 'qualV', 'kableExtra', '')

for(idx_package in package_list){
  if(length(which(row.names(installed.packages()) == idx_package)) > 0){
  suppressMessages(require(package = idx_package,
                                         character.only = TRUE))
  } else {
    paste0(idx_package, " is not installed. Please install ", idx_package, " before continuing.") %>% print()
  }
}

#string for function directory
func_dir = "/Users/lukegraywhiley/Documents/GitHub/metabolomics_code/functions/"

#filelist of datafiles from project path to undergo analysis. Data must be stored in appropiate subfolder.
data_filelist <- list.files(path = paste0(mstr_lst$proj_optns$proj_dir,
                                          mstr_lst$proj_optns$proj_data_subdir),
                            pattern = ".txt",
                            full.names = TRUE)

#set up project list structure and append colours (autogenerated using brewer.pal)
mstr_lst <- lst(proj_details = mstr_lst$proj_optns %>%
                     list_modify(., 
                                 proj_colours = brewer.pal(n= length(.[["proj_classes"]]), name = "Accent"),
                                 sub_projects = array(dim = length(data_filelist))),
                   functions = lst(
                     LGW_FUNC_dataRead = source(paste0(func_dir ,"LGW_FUNC_dataRead.R")),
                     LGW_FUNC_impute = source(paste0(func_dir, "LGW_FUNC_impute_halfmin.R")),
                     LGW_FUNC_pca = source(paste0(func_dir, "Quarto_LGW_FUNC_rPCA.R")),
                     LGW_FUNC_rOPLS = source(paste0(func_dir, "Quarto_LGW_FUNC_rOPLS.R")),
                     LGW_FUNC_univariate = source(paste0(func_dir, "2021_LGW_FUNC_compare_means_ggplot_boxplots.R"))
                     ),
                   tables = lst(proj_overview = lst()))

# read in data


#execute function
for(idx_filepath in 1:length(data_filelist)){
  mstr_lst$proj_details$sub_projects[idx_filepath] <- gsub(x = strsplit(data_filelist[idx_filepath], paste0(mstr_lst$proj_details$proj_data_subdir, "/"))[[1]][2], pattern = ".csv", replacement = "")
 
  mstr_lst[[mstr_lst$proj_details$sub_projects[idx_filepath]]] <- lst(
    data = lst(
      master_data = mstr_lst$functions$LGW_FUNC_dataRead$value(
        FUNC_datapath = data_filelist[idx_filepath],
        FUNC_annotation_tag = "sample"),
      sample_filtered = lst(),
      feature_filtered = lst(),
      imputed_data = lst()
  ))
  
  idx_data <- mstr_lst$proj_details$sub_projects[idx_filepath]
  
#add factor columns for control of colours for plotting
  mstr_lst[[idx_data]]$data$master_data$annotation <- mstr_lst[[idx_data]]$data$master_data$annotation %>%
    #sample_class
    mutate(across(.cols = all_of(mstr_lst$proj_details$proj_class_column_header),
                  .fns = ~factor(.x, levels = c(mstr_lst$proj_details$proj_classes), ordered = TRUE),
                  .names = "sample_class_factor")) %>%
    #sample type
    mutate(across(.cols = sample_type,
                  .fns = ~factor(.x, levels = c("qc", "sample"), ordered = TRUE),
                  .names = "sample_type_factor")) %>%
    #sample_batch
    mutate(across(.cols = sample_batch,
                  .fns = ~factor(.x, levels = unique(.), ordered = TRUE),
                  .names = "sample_batch_factor"))
             
  #filter to only include sample classes desired by user
        #find idx of rows containg sample_class defined by user as proj_classes in chunk 1.
  keep_idx_class <- which(
    mstr_lst[[idx_data]]$data$master_data$annotation[[mstr_lst$proj_details$proj_class_column_header]] %in% mstr_lst$proj_details$proj_classes)

    #run apply to remove sample classes not desired by user
  mstr_lst[[idx_data]]$data$master_data[1:2] <- lapply(
    X = mstr_lst[[idx_data]]$data$master_data[1:2], 
    FUN = function(x) x[keep_idx_class,])
  
  #create summary tibble for printing
  mstr_lst$tables$proj_overview <- mstr_lst$tables$proj_overview %>%
    bind_rows(., tibble(
      project = idx_data,
      features = ncol(mstr_lst[[idx_data]]$data$master_data$data),
      total_samples = nrow(mstr_lst[[idx_data]]$data$master_data$annotation),
      qc_samples = nrow(mstr_lst[[idx_data]]$data$master_data$annotation %>% 
                          filter(sample_type =="qc")),
      study_samples = nrow(mstr_lst[[idx_data]]$data$master_data$annotation %>% 
                             filter(sample_type =="sample"))
      ) %>% bind_cols(.,
      mstr_lst[[idx_data]]$data$master_data$annotation[[mstr_lst$proj_details$proj_class_column_header]] %>%
        table() %>% as.matrix %>% t %>% as_tibble())
    )
  
  #set result lst for exporting results
  mstr_lst[[idx_data]]$results <- lst()
  }


#print table for report
mstr_lst$tables$proj_overview %>% 
  kbl(align = "c") %>% 
  kable_minimal("hover", full_width = T)
```

## Sample outlier removal

```{r sample outlier removal, eval = FALSE, echo = TRUE, warning=FALSE}

# this chunk is to subset data, removing outliers
# if no outliers - set as NA

#set empty list
mstr_lst$tables$proj_overview_filtered <- lst()

for(idx_data in mstr_lst$proj_details$sub_projects){
  
  if(is.na(mstr_lst$proj_details$proj_outliers)){
  mstr_lst[[idx_data]]$data$sample_filtered <- mstr_lst[[idx_data]]$data$master_data
  mstr_lst$tables$proj_overview_filtered <- mstr_lst$tables$proj_overview
  #cat("No outliers removed")
  } else {
  
  #find idx of rows containg sample_class defined by user as proj_classes in chunk 1.
  keep_idx_class <- which(mstr_lst[[idx_data]]$data$master_data$annotation[[mstr_lst$proj_details$proj_class_column_header]] %in% mstr_lst$proj_details$sample_class)  
  #find idx of rows that are not outliers defined by user as proj_outliers in chunk 1.
  keep_idx_outlier <- which(!mstr_lst[[idx_data]]$data$master_data$annotation$sample_name %in% mstr_lst$proj_details$proj_outliers)

  #run apply to remove outliers
  mstr_lst[[idx_data]]$data$sample_filtered[1:2] <- lapply(X = mstr_lst[[idx_data]]$data$master_data[1:2], 
                                                            FUN = function(x) x[keep_idx_outlier,])
  
  #add feature list to filtered data
   mstr_lst[[idx_data]]$data$sample_filtered[3] <-  mstr_lst[[idx_data]]$data$master_data[3]
  
     mstr_lst$tables$proj_overview_filtered <- mstr_lst$tables$proj_overview_filtered %>%
    bind_rows(.,
              tibble(project = (mstr_lst[[idx_data]]$data$sample_filtered %>% names()),
                     features = ncol(mstr_lst[[idx_data]]$data$sample_filtered$data),
                     total_samples = nrow(mstr_lst[[idx_data]]$data$sample_filtered$annotation),
                     qc_samples = nrow(mstr_lst$data$master_data[[idx_filepath]]$annotation %>% filter(sample_type =="qc")),
                     study_samples = nrow(mstr_lst[[idx_data]]$data$sample_filtered$annotation %>% filter(sample_type =="sample"))
                     ) %>%
                bind_cols(. ,
                          mstr_lst[[idx_data]]$data$sample_filtered$annotation[[mstr_lst$proj_details$proj_class_column_header]] %>% table() %>% as.matrix %>% t %>% as_tibble())
              )
  }
}

#clean environment
rm(list = c(ls()[which(ls() != "mstr_lst")]))

if(is.na(mstr_lst$proj_details$proj_outliers)){cat("No outliers removed")} else {
  cat("Updated sample table:")
  mstr_lst$tables$proj_overview_filtered %>% 
  kbl(align = "c") %>% 
  kable_minimal("hover", full_width = T)
}
```

## Feature outlier removal

-   Features are removed that have \> 50% missing values

-   Removed features:

```{r feature outlier removal, eval = FALSE, echo = TRUE, warning=FALSE}

#remove features that have > x missing values

for(idx_data in mstr_lst$proj_details$sub_projects){
  #set data
  mstr_lst[[idx_data]]$data[["feature_filtered"]] <- mstr_lst[[idx_data]]$data$sample_filtered
  
  #get names of metabolites with >50% missing values
mstr_lst[[idx_data]]$data$feature_filtered[["failed_features"]] <- which(
  (colSums(is.na(mstr_lst[[idx_data]]$data$sample_filtered$data))/
     nrow(mstr_lst[[idx_data]]$data$sample_filtered$data))*100 > 50) %>% names()
 
mstr_lst[[idx_data]]$data[["feature_filtered"]]$data <-  mstr_lst[[idx_data]]$data[["feature_filtered"]]$data %>%
  select(-all_of(mstr_lst[[idx_data]]$data$feature_filtered[["failed_features"]]))

mstr_lst[[idx_data]]$data[["feature_filtered"]]$features <- mstr_lst[[idx_data]]$data[["feature_filtered"]]$data %>%
  names()
}

mstr_lst[[idx_data]]$data$feature_filtered[["failed_features"]]
```

## Missing value and imputation overview

-   Missing values also include NA, NaN and zeros

-   Missing values are treated as \< lower limit of detection (LLOD)

-   Imputation is computed individually for each metabolite.

-   Missing values are filled using the half minimum concentration value for each metabolite.

```{r missing value overview and impute, eval = FALSE, echo = TRUE}

mstr_lst$functions$LGW_FUNC_impute <- source('/Users/lukegraywhiley/Documents/GitHub/metabolomics_code/functions/LGW_FUNC_impute_halfmin.R')

#set empty table for output
mstr_lst$tables$missing_values_table <- lst()

#run impution loop for each dataset
for(idx_data in mstr_lst$proj_details$sub_projects){
      mstr_lst[[idx_data]]$data$imputed_data <- list(
        annotation = mstr_lst[[idx_data]]$data$feature_filtered$annotation,
        data = mstr_lst$functions$LGW_FUNC_impute$value(x = mstr_lst[[idx_data]]$data$feature_filtered$data),
        features = mstr_lst[[idx_data]]$data$feature_filtered$features
      )
  
      #create table for report
      
      #1. data to shorthand object
      pre_data <- mstr_lst[[idx_data]]$data$feature_filtered$data
      pre_data_missing <- length(which(pre_data==0)) + length(which(is.na(pre_data)))
      post_data <- mstr_lst[[idx_data]]$data$imputed_data$data
      post_data_missing <- length(which(post_data==0)) + length(which(is.na(post_data)))
      
    
      #. calculate output table
    mstr_lst$tables$missing_values_table <- mstr_lst$tables$missing_values_table %>%
      bind_rows(., bind_cols(
        "project" = idx_data,
        "pre-impute: missing values (%)" = paste0(pre_data_missing, " (", round((100/prod(dim(pre_data)))*pre_data_missing,2),")"),
        "post-impute: missing values (%)" = paste0(post_data_missing, " (", round((100/prod(dim(post_data)))*post_data_missing,2),")")
        ))
}


#clean environment
rm(list = c(ls()[which(ls() != "mstr_lst")]))

#print table for report
mstr_lst$tables$missing_values_table %>% 
  kbl(align = "c") %>% 
  kable_minimal("hover", full_width = T)

```

<br />

## Results

### Multivariate data analysis

#### Principal Component Analysis (PCA)

-   Principal Component Analysis (PCA) was conducted to check the quality of the data. PCA is an unsupervised model (i.e. no prior group information is supplied to the model, labelling and colours applied after the model construction). This allows for observations on the quality of the dataset

-   Patterns in the data between samples can also be observed - this may be as a result of either biological or analytical differences - e.g. differences in sample collection, handling or storage

##### Pre-processed data - no batch or signal drift correction

```{r PCA, eval = FALSE, echo = TRUE, warning = FALSE}

#create a html taglist (work around for rendering plotly html in a loop in .RMD documents) and set up iterative idx (i)
print_lst <- htmltools::tagList(); i <- 1

#run loop
for(idx_data in mstr_lst$proj_details$sub_projects){
  #pca_lst to store PCA settings for loop
  pca_lst <- lst(
    "sample type" = lst(header = "sample_type_factor", include_qc = TRUE, include_sample = TRUE,
                        plot_colours = c("steelblue1", "white")),
    "batch [all samples]" = lst(header = "sample_batch_factor", include_qc = TRUE, include_sample = TRUE,
                                plot_colours = c(brewer.pal(n = length(unique(
                                  mstr_lst[[idx_data]]$data$imputed_data$annotation$sample_batch_factor)), name = "Accent"))),
    "batch [qc samples only]" = lst(header = "sample_batch_factor", include_qc = TRUE, include_sample = FALSE,
                                    c(brewer.pal(n = length(unique(
mstr_lst[[idx_data]]$data$imputed_data$annotation$sample_batch_factor)), name = "Accent"))),
    "sample class" = lst(header = "sample_class_factor", include_qc = TRUE, include_sample = TRUE,
                         plot_colours = mstr_lst$proj_details$proj_colours[which(
                           levels(mstr_lst[[idx_data]]$data$imputed_data$annotation$sample_class_factor) %in%
                             unique( mstr_lst[[idx_data]]$data$imputed_data$annotation[[mstr_lst$proj_details$proj_class_column_header]]))]),
  )

  # complete PCA analysis
  for(idx_pca in names(pca_lst)){
    mstr_lst[[idx_data]]$results$pca[[idx_pca]] <- mstr_lst$functions$LGW_FUNC_pca$value(
                    FUNC_data = bind_cols(mstr_lst[[idx_data]]$data$imputed_data$annotation, 
                                          mstr_lst[[idx_data]]$data$imputed_data$data),
                    FUNC_metabolite_list = mstr_lst[[idx_data]]$data$imputed_data$features,
                    FUNC_STRING_title = paste0("PCA (coloured by ",idx_pca,"); ", idx_data),
                    FUNC_STRING_legend_title = idx_pca,
                    FUNC_HEADER_colour_by = pca_lst[[idx_pca]]$header,
                    FUNC_HEADER_plot_label = "sample_id",
                    FUNC_OPTION_scaling = "standard",
                    FUNC_OPTION_log_data = TRUE,
                    FUNC_OPTION_plot_colours = pca_lst[[idx_pca]]$plot_colours,
                    FUNC_OPTION_invert_x = FALSE,
                    FUNC_OPTION_invert_y = FALSE,
                    FUNC_OPTION_include_qc = pca_lst[[idx_pca]]$include_qc,
                    FUNC_OPTION_include_sample = pca_lst[[idx_pca]]$include_sample
    )
        print_lst[[i]] <- mstr_lst[[idx_data]]$results$pca[[idx_pca]]$plot_combined; i <- i+1
      }}
  
print_lst

```

#### Orthogonal Projections to Latent Structures Discriminant Analysis (OPLS-DA)

-   Orthogonal Projections to Latent Structures Discriminant Analysis (OPLS-DA) was conducted to identify separation between the groups

-   OPLS-DA is a supervised model, where groups are pre-defined before modelling. It can be used as a classifier to see observe differences in the metabolite data that exist between the two classes e.g. (control vs case).

```{r OPLS-DA, eval = FALSE, echo = TRUE,  warning=FALSE, results='asis'}

#create a html taglist (work around for rendering plotly html in a loop in .RMD documents) and start iterative idx for printing
print_list <- htmltools::tagList(); i <- 1

for(idx_data in mstr_lst$proj_details$sub_projects){ 
  mstr_lst[[idx_data]]$results$opls <- lst()
  #create OPLS-DA
  mstr_lst[[idx_data]]$results$opls <- mstr_lst$functions$LGW_FUNC_rOPLS$value(
    FUNC_data = bind_cols(mstr_lst[[idx_data]]$data$imputed_data$annotation,
                          mstr_lst[[idx_data]]$data$imputed_data$data), 
    FUNC_metabolite_list = mstr_lst[[idx_data]]$data$imputed_data$features,
    FUNC_OPLS_comparison_control = mstr_lst$proj_details$opls$control,
    FUNC_OPLS_comparison_test = mstr_lst$proj_details$opls$case,
    FUNC_HEADER_class = "sample_class_factor",
    FUNC_OPTION_colour_by = "sample_class_factor",
    FUNC_OPTION_plot_label = "sample_id",
    FUNC_OPTION_scaling = "pareto",
    FUNC_OPTION_log_data = TRUE,
    FUNC_OPTION_title = "",
    FUNC_OPTION_proj_colours = mstr_lst$proj_details$proj_colours,
    FUNC_OPTION_max_orth = 1,
    FUNC_OPTION_invert_x = FALSE,
    FUNC_OPTION_invert_y = FALSE
  )
 
  #add to print list for rendering in report, add iterative idx
  for(idx_case in names(mstr_lst[[idx_data]]$results$opls)){
  print_list[[i]] <- mstr_lst[[idx_data]]$results$opls[[idx_case]]$plot_combined; i <- i+1
  print_list[[i]] <- mstr_lst[[idx_data]]$results$opls[[idx_case]]$loading_bar; i <- i+1
}
}
print_list

```

### Univariate analysis

-   Inter-group means were compared using non-parametric analysis (Kruskal-Wallis)\
-   Individual lipids that returned a p value of \< 0.05, then underwent analysis using Dunn's test, to report specific inter-group differences\
-   Significant lipids from the test are displayed in the table

#### Results table

<br />

```{r compare means, eval=FALSE, echo=TRUE, warning=FALSE, error=FALSE, message=FALSE,results='asis'}

for(idx_data in mstr_lst$proj_details$sub_projects){
  mstr_lst[[idx_data]]$results$univariate <- lst()

#create a html taglist (work around for rendering kable html in a loop in .RMD documents) and start iterative idx for printing
print_list <- htmltools::tagList(); i <- 1
  #find project colours to use to consistently match PCA and OPLS
  plot_colours <- mstr_lst$proj_details$proj_colours[which(
    levels(mstr_lst[[idx_data]]$data$imputed_data$annotation$sample_class_factor) %in% mstr_lst$proj_details$univariate$comparison)]

    #perform univariate and stats 
  mstr_lst[[idx_data]]$results$univariate <- mstr_lst$functions$LGW_FUNC_univariate$value(
    FUNC_data = bind_cols(mstr_lst[[idx_data]]$data$imputed_data$annotation,
                          mstr_lst[[idx_data]]$data$imputed_data$data),
    FUNC_metabolite_list = mstr_lst[[idx_data]]$data$imputed_data$features,
    FUNC_class_to_include = mstr_lst$proj_details$univariate$comparison,
    FUNC_HEADER_class = "sample_class_factor",
    FUNC_HEADER_colour = "sample_class_factor",
    FUNC_OPTION_colour_choice <- plot_colours, 
    FUNC_OPTION_log_plot_data = FALSE,
    FUNC_OPTION_compare_means_method = mstr_lst$proj_details$univariate$method, #OPTIONS = kruskal.test, wilcox.test, wilcox.test.paired
    FUNC_HEADER_paired = NA, #if paired test is desired add here the linking column header, else = NA
    FUNC_plot_comparisons = NA, ##only required for specific Mann.Whitney; e.g. c("admission - presurgery")
    FUNC_OPTION_plot_qc = FALSE,
    FUNC_OPTION_plot_show_legend = FALSE,
    FUNC_OPTION_plot_outliers = FALSE,
    FUNC_OPTION_point_size = 1
)
  
  # p value control for multiple testing
  mstr_lst[[idx_data]]$results$univariate$table <- mstr_lst[[idx_data]]$results$univariate$table %>%
    select(-"p.adj", - "p.format") %>%
    add_column(padj = p.adjust(p =  mstr_lst[[idx_data]]$results$univariate$table$p, method = "BH"), 
               .after = "p") %>%
    arrange(p)
  
  #add kable to print_list for report
mstr_lst[[idx_data]]$results$univariate$table %>%
  kbl(align = "c", booktabs = TRUE, longtable = TRUE) %>%
  kable_minimal("hover") %>%
  kable_styling(font_size = 10) %>%
  scroll_box(height = "500px") %>% print()


}




```

#### Univariate boxplots

-   Boxplots for metabolites that returned a Kruskal Wallis \<0.05 are displayed below

-   The False Discovery Rate was controlled using the method proposed by Bejamini and Hochburg

Boxplot annotation:\
\* = p\<0.05\
\*\* = p\<0.01\
\*\*\* = p\<0.001\
\*\*\*\* = p\<0.0001

```{r print boxplots, eval=FALSE, echo=TRUE, warning=FALSE, error=FALSE, message=FALSE,results='asis', fig.width=2.8, fig.height=2.8, out.height="80%", out.width = "80%", dpi=300, fig.show="hold"}

  #print sig boxplots
  for(idx_data in mstr_lst$proj_details$sub_projects){
sig_max <- which(mstr_lst[[idx_data]]$results$univariate$table$padj <0.05) %>% max()
for (idx_plot in mstr_lst[[idx_data]]$results$univariate$table$feature[1:sig_max]){
print(mstr_lst[[idx_data]]$results$univariate$bp[[idx_plot]])
}
}

```
