---
title: Heidelberg data QC
subtitle: Tryptophan
author: Luke Whiley
date: "`r format(Sys.time(), '%d %B, %Y')`"
format:
  html:
    code-fold: true
    code-tools: true
    df-print: paged
    toc: true
    toc-depth: 5
    self-contained: TRUE
editor: visual
theme: cosmo
---

```{r notebook instructions, eval=FALSE}
# Quarto notebook for metabolomics data quality control
# Notebook will perform the following tasks:
# import data that has been exported from processing software
# create calibration, QC data, filter data, report data
# Notebook instructions:
  #>Enter user options in chunk 1
  #> project folder must be set up as ~parent_directory and include the subdirectories:
        #>  ~parent_directory/data
        #>  ~parent_directory/SIL_template
  #> default data type: import = .txt; export = .csv

# required packages: 'tidyverse', 'janitor', 'qualV', 'kableExtra', 'plotly', 'manipulateWidget', 'RColorBrewer'

```

## Data import

<!--# USER INPUT HERE -->

```{r user setup; project structure, eval=TRUE, echo=TRUE}
#USER INPUT REQUIRED BELOW
#enter the ~parent_directory loaction here
parent_directory_path = "/Users/lukegraywhiley/Downloads/temp_data/test_qc/"

#----------------------------- NO USER INPUTE REQUIRED BELOW THIS LINE
#----------------------------- set project structure
package_list <- c('tidyverse', 'janitor', 'qualV', 'kableExtra', 'plotly', 'manipulateWidget', 'RColorBrewer')

for(idx_package in package_list){
  if(length(which(row.names(installed.packages()) == idx_package)) > 0){
    suppressMessages(require(package = idx_package,
                             character.only = TRUE))
  } else {
    paste0(idx_package, " is not installed. Please install ", idx_package, " before continuing.") %>% print()
  }
}

#----------------------------- set project structure
mstr_lst <- list(
  proj_optns = list(
    #proj_name = "QC testR; Tryptophan", #name of project
    #usr_name = "LGW", #user of project
    proj_dir = parent_directory_path,
    proj_data_subdir = "data",# sub directory contatining export data from TargetLynx
    proj_SILtemplate_subdir = "SIL_template",
    data_type = ".txt", # import flie type [.txt as default]
    keep_header = c("area") # header to keep [e.g c("response", "conc", "area") etc]
  )) %>% 
  list_modify(
  data = list(
    imprt_lst = list.files(paste0(.$proj_optns$proj_dir, .$proj_optns$proj_data_subdir), full.names = TRUE, pattern = ".txt"),
    plate_lst = list.files(paste0(.$proj_optns$proj_dir, .$proj_optns$proj_data_subdir), full.names = FALSE, pattern = ".txt"),
    SIL_template = read.csv(
      file = list.files(paste0(.$proj_optns$proj_dir, .$proj_optns$proj_SILtemplate_subdir), full.names = TRUE)),
    std_conc = list(),
    area = list(),
    response = list()),
  tbls = list(
    imprt_tbl = list(),
    calib_summary = list(tibble("metabolite" = character(), "data_type" = character(), "reason" = character()))),
  control_charts = list(),
  calib = list(
    conc = list(),
    response = list(),
    area = list()
  )
)


```

-   Data is imported into R from .txt files produced in targetlynx (Waters inc.).

-   Once imported data is reorganized from a long .txt export into managable dataframes and appended to a master data list

-   Data import summary:

```{r read in and flip data, eval=TRUE, echo=TRUE, paged.print=TRUE, warning=FALSE, results='asis'}
#--------- read in data from targetlynx
#--------- write flippR function
targetlynx_flippR <- function(FUNC_txt_file_path,
                              FUNC_keep_hdr){
flippR_list <- list(
  data = read.delim(file = paste(FUNC_txt_file_path), sep = "\t",header=FALSE) %>% as_tibble() %>%
         set_names(., .[which(. == "Name", arr.ind=TRUE)[1,1],]) %>% clean_names()) %>%
    list_modify(
      metabolites = unique(
        .$data$x[grep("Compound", .$data$x)]) %>% .[-grep("Report", .)] %>% sub(".*:  ", "", .), 
      filtered_data = filter(.$data ,name != "" & name != "Name")
      ) %>% 
  list_modify(
    duplicate_samples = .$filtered_data[1:(length(unique(.$filtered_data$x))),][["name"]] %>% duplicated()
  ) 
#flag duplicates
flippR_list$filtered_data$name[flippR_list$duplicate_samples] <- paste0(
  flippR_list$filtered_data$name[flippR_list$duplicate_samples],"_DUPLICATED")
#spread data
 flippR_list <- flippR_list %>%
   list_modify(
      spread_data = add_column(.$filtered_data, 
                               metabolite = rep(.$metabolites, 
                                                each = length(unique(.$filtered_data$name)))) %>% 
        select(name, type, metabolite,  all_of(FUNC_keep_hdr)) %>% 
        mutate_at(.vars = all_of(FUNC_keep_hdr), .funs = as.numeric) %>%
        spread(key = metabolite, value = all_of(FUNC_keep_hdr))
      )
    flippR_list$spread_data
  }

#--------- apply flippR function to files in ~parent_directory/data subfolder
#run flippR function and keep area and std_concs
for(idx_file in 1:length(mstr_lst$data$imprt_lst)){
  mstr_lst$data[["std_conc"]] <- mstr_lst$data[["std_conc"]] %>%
    bind_rows(targetlynx_flippR(FUNC_txt_file_path = mstr_lst$data$imprt_lst[idx_file], FUNC_keep_hdr = "std_conc") %>%
                add_column(plate = rep(mstr_lst$data$plate_lst[idx_file], nrow(.)), .before = 1))
 mstr_lst$data[["area"]] <- mstr_lst$data[["area"]] %>%
    bind_rows(targetlynx_flippR(FUNC_txt_file_path = mstr_lst$data$imprt_lst[idx_file], FUNC_keep_hdr = "area") %>%
                add_column(plate = rep(mstr_lst$data$plate_lst[idx_file], nrow(.)), .before = 1))

 #create summary table for report printing
mstr_lst$tbls[["imprt_tbl"]] <- bind_rows(
  mstr_lst$tbls[["imprt_tbl"]],
  bind_cols(plate = mstr_lst$data$plate_lst[idx_file],
            standards = nrow(
              mstr_lst$data$std_conc %>% filter(plate == mstr_lst$data$plate_lst[idx_file] & type == "Standard")),
            qc = nrow(
              mstr_lst$data$std_conc %>% filter(plate == mstr_lst$data$plate_lst[idx_file] & type == "QC")),
            samples = nrow(
              mstr_lst$data$std_conc %>% filter(plate == mstr_lst$data$plate_lst[idx_file] & type == "Analyte")),
            blanks = nrow(
              mstr_lst$data$std_conc %>% filter(plate == mstr_lst$data$plate_lst[idx_file] & type == "Blank")),
            features = ncol(mstr_lst$data$std_conc)-2
            ))
}
#add summary row for all plates
mstr_lst$tbls$imprt_tbl <- mstr_lst$tbls$imprt_tbl %>%
  bind_rows(tibble(
    plate = "total", standards = sum(.$standards), qc = sum(.$qc), samples = sum(.$samples), 
    blanks = sum(.$blanks), features = sum(.$features))
  )

#print table in report
mstr_lst$tbls$imprt_tbl %>%
  kbl(align = "c", booktabs = TRUE, longtable = TRUE) %>%
  kable_minimal("hover") %>%
  kable_styling(font_size = 12) %>%
  scroll_box() %>% print()


```

## Control charts - Calibration and QC samples

Control charts produced for each metabolite for each of the calibration and QC injections:

-   Peak area of target

-   peak area of SIL internal standard

-   response ratio

```{r Cal and QC control charts, eval=TRUE, echo=TRUE, paged.print=FALSE, warning=FALSE}
#--------------------------------------------------------------------------------------------------------------------------- 
#FUNCTION Cal and QC control_plotR
#--------------------------------------------------------------------------------------------------------------------------- 
# requires a dataframe with column headers plate, name, type, level, area, response, SIL area

CalQC_controlPlotR <- function(FUNC_data){
  #change "Standard" annotation to "Calibration"
  FUNC_data$type[which(FUNC_data$type == "Standard")] <- "Calibration"
  #set level factor to control plotting
  FUNC_data$level_factor <- paste0(FUNC_data$type, "_", FUNC_data$std_conc) 
  FUNC_data$level_factor <- factor(FUNC_data$level_factor,
                                   levels = unique((FUNC_data %>% arrange(type, std_conc))[["level_factor"]]),
                                   ordered = TRUE)
  #turn into long table to allow for facet wrap
  FUNC_data <- FUNC_data %>%
    gather(key = "datatype", value = "value", -plate, - name, -type, - std_conc, - level_factor)
  #set type as factor to control facetwrap
  FUNC_data$type <- factor(paste0(FUNC_data$type, "_", FUNC_data$datatype),
                           levels = sort(unique(paste0(FUNC_data$type, "_", FUNC_data$datatype))),
                           ordered = TRUE)
  #set plot colors and group to control plotly legend
  plot_colours <- c(brewer.pal(n = length(unique(FUNC_data$level_factor)), name = "Set3")) %>% 
    setNames(unique(FUNC_data$level_factor))
  #set plot size and group to control plotly legend
  plot_shape <- rep(21, length(unique(FUNC_data$level_factor))) %>% 
    setNames(unique(FUNC_data$level_factor))
  #set plot fill to black to aid visuals and group to control plotly legend
  plot_fill <- rep("black", length(unique(FUNC_data$level_factor))) %>% 
    setNames(unique(FUNC_data$level_factor))
  #create ggplot
  FUNC_plot <- ggplot(data = FUNC_data,
                      aes(x=plate, y=log(value+1), color=level_factor, fill = level_factor, shape = level_factor, 
                          group = level_factor)) + 
    geom_point() + 
    geom_line() + 
    theme_classic() +
    labs(y = paste0("log[value]"), x = NULL)+
    theme(plot.title = element_blank(),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          legend.text = element_text(size = 5),
          legend.title = element_text(size = 5),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank()) +
    scale_x_discrete(expand = c(0.1,0.1)) +
    scale_colour_manual(values = plot_colours,
                        labels = names(plot_colours)) +
    scale_fill_manual(values = plot_fill,
                      labels = names(plot_fill)) +
    scale_shape_manual(values = plot_shape,
                       labels = names(plot_shape)) +
    facet_wrap(~type, ncol = 2, scales = "free", dir = "v")
#export as plotly
  FUNC_plot
}

#--------------------------------------------------------------------------------------------------------------------------- 
# application of function to data
#--------------------------------------------------------------------------------------------------------------------------- 
#re-order sil_template to put NA at bottom
mstr_lst$data$SIL_template <- mstr_lst$data$SIL_template[order(is.na(mstr_lst$data$SIL_template$SIL_standard)),]
# for those metabolites that have a linked SIL internal standard create a response ratio
for(idx_metabolite in mstr_lst$data$SIL_template$standard){
  SIL_used = mstr_lst$data$SIL_template$SIL_standard[mstr_lst$data$SIL_template$standard==idx_metabolite]
if(!is.na(SIL_used)){
  #create response ratio
   mstr_lst$data$response[[idx_metabolite]] <- mstr_lst$data$area %>%
     select(plate, name, type, all_of(c(idx_metabolite, SIL_used))) %>%
     add_column(std_conc = mstr_lst$data$std_conc[[idx_metabolite]], .before = idx_metabolite) %>%
     mutate_at(c("std_conc", idx_metabolite, SIL_used), as.numeric) %>%
     mutate(response = .[[idx_metabolite]]/.[[SIL_used]])
  
  #produce control chart
  mstr_lst$control_charts[[idx_metabolite]] <- CalQC_controlPlotR(
     FUNC_data = mstr_lst$data$response[[idx_metabolite]] %>%
       rename_at(idx_metabolite, ~paste0("area")) %>%
       rename_at(SIL_used, ~paste0("area_SIL")) %>%
       filter(type == "Standard" | type == "QC")
     )
  
  #print metabolite header report
  cat("###", " ", paste0(idx_metabolite, "\n"))
  #print SIL IS used
  cat("#####", " Internal standard used:", paste0(SIL_used, "\n"))
  #print control chart plot in report
  print(mstr_lst$control_charts[[idx_metabolite]])
} 
  
  if(is.na(SIL_used)){
    #produce control chart
  mstr_lst$control_charts[[idx_metabolite]] <- CalQC_controlPlotR(
     FUNC_data = left_join(by="name",
                           mstr_lst$data$std_conc %>%
                             select(plate, name, type, all_of(idx_metabolite)) %>%
                             rename_at(idx_metabolite, ~paste0("std_conc")),
                           mstr_lst$data$area %>%
                             select(name, all_of(idx_metabolite)) %>%
                             rename_at(idx_metabolite, ~paste0("area"))) %>% 
       filter(type == "Standard" | type == "QC")
     )
  
    #print metabolite header report
  cat("###", " ", paste0(idx_metabolite, "\n"))
  #print SIL IS used
  cat("#####", " No internal standard selected", "\n")
  #print control chart plot in report
  print(mstr_lst$control_charts[[idx_metabolite]])
  cat("\n")
 }
}


```

<!--# coding of calibration, linear model plot and control chart plot visualisation functions -->

```{r calibration functions, eval=FALSE, echo=TRUE, paged.print=FALSE, warning=FALSE}

#--------------------------------------------------------------------------------------------------------------------------- 
# FUNCTION calibratR 
#--------------------------------------------------------------------------------------------------------------------------- 
calibratR <- function(FUNC_data,
                      FUNC_HEADER_cal,
                      FUNC_STRING_std,
                      FUNC_STRING_qc,
                      FUNC_STRING_sample,
                      FUNC_STRING_title){
  FUNC_list <- list(
    lmX_data = FUNC_data %>%
      filter(type == FUNC_STRING_std) %>%
      add_column("weights" = 1/(.[[FUNC_HEADER_cal]]^2))
    ) %>%
    list_modify(
    #build lm model (FUNC_HEADER_cal ~ std_conc, weighted by 1/x^2)
    lmX = lm(data = .$lmX_data,
             formula = paste0(FUNC_HEADER_cal, " ~ std_conc"),
             weights = weights)
    ) %>% list_modify(
      percent_dev = 100*(resid(.$lmX)/.$lmX_data[[FUNC_HEADER_cal]]), #calculate percentatge residuals
      fail_list = NULL, #create empty list for fail list
      cal_length = NULL #create empty list for cal length (# of cal points)
    )
  
  #run a while loop to assess calibration, and if necessary remove points and rebuild
  while((summary(FUNC_list$lmX)$adj.r.squared < 0.99 | 
        max(abs(FUNC_list$percent_dev)) > 25) &
        length(FUNC_list$percent_dev) > 5){
    max_fail_idx <- which.max(abs(as.numeric(FUNC_list$percent_dev)))
    FUNC_list$fail_list <- c(FUNC_list$fail_list, FUNC_list$lmX_data$std_conc[[max_fail_idx]])
    FUNC_list$lmX_data <- FUNC_list$lmX_data[-max_fail_idx, ]
    FUNC_list$lmX <- lm(data = FUNC_list$lmX_data,
                        formula = paste0(FUNC_HEADER_cal, " ~ std_conc"),
                        weights = weights)
    FUNC_list$cal_length <- length(FUNC_list$lmX_data$std_conc)
    FUNC_list$percent_dev <- 100*(resid(FUNC_list$lmX)/FUNC_list$lmX_data[[FUNC_HEADER_cal]])
  }
  
  #create tibble containing prediction data
  FUNC_list$lmX_pred_data <- FUNC_data %>%
      filter(!name %in% FUNC_list$lmX_data$name) %>%
      add_column("weights" = 1/(.[[FUNC_HEADER_cal]]^2))
  
  #back calculate conc from response for remaining data
  FUNC_list$lmX_pred_data$calc_conc <- 
    (FUNC_list$lmX_pred_data[[FUNC_HEADER_cal]] - FUNC_list$lmX$coefficients[1])/FUNC_list$lmX$coefficients[2]
  
  #evaluate QC performance
  FUNC_list$qc_summary <- FUNC_list$lmX_pred_data %>%
    filter(type == FUNC_STRING_qc) %>%
    add_column(residual = (.$std_conc/.$calc_conc)*100)
  #ad pass/fail column
  FUNC_list$qc_summary$pass <- TRUE
  FUNC_list$qc_summary$pass[which(abs(100-FUNC_list$qc_summary$residual) > 25)] <- FALSE
  
  #create results table
  FUNC_list$summary_tbl <- tibble(
    plate = FUNC_STRING_title,
    r2 = signif(summary(FUNC_list$lmX)$adj.r.squared, 4),
    intercept = signif(FUNC_list$lmX$coef[[1]],2),
    slope = signif(FUNC_list$lmX$coef[[2]], 2),
    cal_length = length(FUNC_list$percent_dev),
    cal_included = paste(FUNC_list$lmX_data$std_conc, collapse = "; "),
    cal_failed = paste(FUNC_list$fail_list, collapse = "; "),
    qc_pass = paste(FUNC_list$qc_summary$std_conc[which(FUNC_list$qc_summary$pass==TRUE)], collapse = "; "),
    qc_fail = paste(FUNC_list$qc_summary$std_conc[which(FUNC_list$qc_summary$pass==FALSE)], collapse = "; ")
  )
  
  #create calibration plot of calibrants
  #create plot_data
  FUNC_list$plot_data <- bind_rows(
  #pass stds [calibration data]
  FUNC_list$lmX$model %>% rename(conc = std_conc) %>% add_column(type = "std_pass", .before = 1),
  #failed standards
  FUNC_list$lmX_pred_data %>% 
    filter(type == FUNC_STRING_std) %>% 
    rename(conc = std_conc) %>%
    select(response, conc) %>%
    add_column(type = "std_fail"),
  #pass qc
  FUNC_list$lmX_pred_data %>% 
    filter(type == FUNC_STRING_qc) %>% 
    filter(name %in% (filter(FUNC_list$qc_summary, pass == TRUE))[["name"]]) %>%
    rename(conc = std_conc) %>%
    select(response, conc) %>%
    add_column(type = "qc_pass"),
  #fail qc
  FUNC_list$lmX_pred_data %>% 
    filter(type == FUNC_STRING_qc) %>% 
    filter(name %in% (filter(FUNC_list$qc_summary, pass == FALSE))[["name"]]) %>%
    rename(conc = std_conc) %>%
    select(response, conc) %>%
    add_column(type = "qc_fail"),
  #Analyte
  FUNC_list$lmX_pred_data %>% 
    filter(type == FUNC_STRING_sample) %>% 
    rename(conc = calc_conc) %>%
    select(response, conc) %>%
    add_column(type = "study_sample")
) %>% as_tibble() 

  FUNC_list$plot_data$type <- FUNC_list$plot_data$type %>%
    factor(levels = c("study_sample", "std_pass", "qc_pass", "std_fail", "qc_fail"), 
                         ordered = TRUE)

   FUNC_list
  }

#--------------------------------------------------------------------------------------------------------------------------- 
# FUNCTION to create calibration plot
#--------------------------------------------------------------------------------------------------------------------------- 
calibrate_plotR <- function(FUNC_data){
  #set common colours, sizes and shapes
  group_colours <- c("std_pass" = "darkgreen", "std_fail" = "red", "qc_pass" = "darkgreen", "qc_fail" = "red", "study_sample" = "black")
group_sizes <- c("std_pass" = 2.5, "std_fail" = 2.5, "qc_pass" = 2.5, "qc_fail" = 2.5, "study_sample" = 1)
group_shape <- c("std_pass" = 25, "std_fail" = 25, "qc_pass" = 21, "qc_fail" = 21, "study_sample" = 3)

#create plot
 FUNC_plot <- ggplot(data = FUNC_data,
                  aes(x=conc, y=response, color=type, shape=type, size=type)) +
  geom_point() +
  stat_smooth(data = filter(FUNC_data, type == "std_pass"),
              geom = "line", alpha = 0.5, size = 1,method = "lm",
              formula = y ~ x, col = "darkgreen", fullrange = TRUE, se = FALSE,
              mapping = aes(weight = `(weights)`)) +
  scale_size_manual(values = group_sizes, guide = "none") +
  scale_shape_manual(values = group_shape,
                     labels = c("qc_fail", "qc_pass", "std_fail", "std_pass", "study_sample")) +
  scale_color_manual(values = group_colours,
                     labels = c("qc_fail", "qc_pass", "std_fail", "std_pass", "study_sample")) +
 
  theme_bw() +
  theme(plot.title = element_blank(),
        axis.title = element_text(size = 5),
        axis.text = element_text(size = 5),
        legend.text = element_text(size = 5),
        legend.title = element_text(size = 5)) +
  facet_wrap(~plate_id,
             ncol = 3)
 #convert to plotly object
 ggplotly(FUNC_plot)
}


```

<!--# application of calibration functions to data -->

```{r apply calibration functions to data, eval=FALSE, echo=TRUE, paged.print=FALSE, warning=FALSE}

#--------------------------------------------------------------------------------------------------------------------------- 
#Run loop to perform calibration for each target analyte
#--------------------------------------------------------------------------------------------------------------------------- 
#set tibble for calibration data out
mstr_lst$data$calib <- mstr_lst$data$area %>%
  select(plate, name, type) %>%
  filter(type == "Analyte")

for(idx_metabolite in mstr_lst$data$SIL_template$standard){
  #create calibration output list()
  temp_lst <- lst(
  #find SIL used from tempalte
  SIL_used = mstr_lst$data$SIL_template$SIL_standard[which(mstr_lst$data$SIL_template$standard == idx_metabolite)],
  all_plates = lst(
    plot = lst(data = NULL,
               calib = NULL,
               control_chart = NULL),
    summary = NULL,
    lmX_data = NULL,
    lmX_pred_data = NULL
  ))

  if(!is.na(temp_lst$SIL_used)){
  #create response ratio
   mstr_lst$data$response[[idx_metabolite]] <- mstr_lst$data$area %>%
     select(plate, name, type, all_of(c(idx_metabolite, temp_lst$SIL_used))) %>%
     add_column(std_conc = mstr_lst$data$std_conc[[idx_metabolite]], .before = idx_metabolite) %>%
     mutate_at(c("std_conc", idx_metabolite, temp_lst$SIL_used), as.numeric) %>%
     mutate(response = .[[idx_metabolite]]/.[[temp_lst$SIL_used]])
  
   #perform the below for each plate independently
   for(idx_plate in 1:length(mstr_lst$data$plate_lst)){
   #run calibratR function
  temp_lst[[paste0("plate_", idx_plate)]] <- calibratR(
    FUNC_data = mstr_lst$data$response[[idx_metabolite]] %>%
      filter(plate == mstr_lst$data$plate_lst[idx_plate]),
    FUNC_HEADER_cal = "response",
    FUNC_STRING_std = "Standard",
    FUNC_STRING_qc = "QC",
    FUNC_STRING_sample = "Analyte",
    FUNC_STRING_title = paste0(mstr_lst$data$plate_lst[idx_plate])
    )
  
  #append to all_plates
  temp_lst$all_plates$plots[[idx_plate]] <-
    temp_lst[[paste0("plate_", idx_plate)]]$cal_plot
  
   temp_lst$all_plates$summary <- temp_lst$all_plates$summary %>%
     bind_rows(temp_lst[[paste0("plate_", idx_plate)]]$summary_tbl)
   
  temp_lst$all_plates$lmX_data <-
     temp_lst$all_plates$lmX_data %>%
     bind_rows(temp_lst[[paste0("plate_", idx_plate)]]$lmX_data)
   
   temp_lst$all_plates$lmX_pred_data <-
     temp_lst$all_plates$lmX_pred_data %>%
     bind_rows(temp_lst[[paste0("plate_", idx_plate)]]$lmX_pred_data)
   
   #create combined data for plotting with facet wrap
   temp_lst$all_plates$plot$data <- bind_rows(
     temp_lst$all_plates$plot$data,
     temp_lst[[paste0("plate_", idx_plate)]]$plot_data %>%
       add_column(plate_id = paste0("plate", idx_plate, "\n",
                                    "r2=", temp_lst$all_plates$summary$r2[idx_plate],
                                    "; slope=", temp_lst$all_plates$summary$slope[idx_plate],
                                    "; int=", temp_lst$all_plates$summary$intercept[idx_plate]))
   )}
   
   # produce calibration plot
   temp_lst$all_plates$plot$calib <- calibrate_plotR(FUNC_data = temp_lst$all_plates$plot$data) %>% ggplotly()
   
   
   
   #if passes QC append concentration data to CONC
   if(min(temp_lst$all_plates$summary$r2) > 0.99){
   mstr_lst$data$calib <- mstr_lst$data$calib %>%
     left_join(., select(temp_lst$all_plates$lmX_pred_data, name, all_of(idx_metabolite)), 
               by="name") %>%
     rename_at(idx_metabolite, list(~paste0(idx_metabolite, "_CONC")))
   
   #create record in calibration summary table
   mstr_lst$tbls$calib_summary <- mstr_lst$tbls$calib_summary %>% 
     bind_rows(
       tibble(metabolite = idx_metabolite, data_type = "conc", reason = "pass calibration"))
   
   #append temp_list to mstr_lst$calib$conc
   mstr_lst$calib$conc[[idx_metabolite]] <- temp_lst
     
   } else {
     #if metabolite fails quantification QC, keep and append response values to mstr_lst
       mstr_lst$data$calib <- mstr_lst$data$calib %>%
     left_join(., select(mstr_lst$data$response[[idx_metabolite]], name, response),
               by = "name") %>%
     rename_at("response", list(~paste0(idx_metabolite, "_RESPONSE")))
       
       #create record in calibration summary table
   mstr_lst$tbls$calib_summary <- mstr_lst$tbls$calib_summary %>% 
     bind_rows(
       tibble(metabolite = idx_metabolite, data_type = "area", reason = "failed calibration"))
   
    #append temp_list to mstr_lst$calib$conc
   mstr_lst$calib$response[[idx_metabolite]] <- temp_lst
  
   } #end of response if
   
  }else{
     
    #if there is no IS only keep and append areas to mstr_lst
   mstr_lst$data$calib <- mstr_lst$data$calib %>%
     left_join(., select(mstr_lst$data$area, name, all_of(idx_metabolite)), by = "name") %>%
     rename_at(idx_metabolite, list(~paste0(idx_metabolite, "_AREA")))
    
   #create record in calibration summary table
   mstr_lst$tbls$calib_summary <- mstr_lst$tbls$calib_summary %>% 
     bind_rows(
       tibble(metabolite = idx_metabolite, data_type = "area", reason = "no IS in template"))
      }
}

# mstr_lst$tbls$calib_summary %>%
#         kbl(align = "c", booktabs = TRUE, longtable = TRUE) %>%
#         kable_minimal("hover") %>%
#         kable_styling(font_size = 10) %>%
#         scroll_box(height = "500px")
```

## 

```{r control charts, eval=FALSE, echo=TRUE, paged.print=FALSE, warning=FALSE, results='asis'}
#create empty rmd list for knit_child workaround
temp_rmd_list <- list()


#run loop for each metabolite that passes QC
for(idx_metabolite in names(mstr_lst$calib$conc)){
  temp_plot <- combineWidgets(
    mstr_lst$calib$conc[[idx_metabolite]]$all_plates$plot$control_chart,
    height = 800
    )
  #create temp rmd file using sink
  temp_rmd_path <- paste0(mstr_lst$proj_optns$proj_dir, idx_metabolite, ".rmd")
  temp_rmd_list[[idx_metabolite]] <- temp_rmd_path
  sink(file = temp_rmd_path)
  cat("  \n", "### ", idx_metabolite, "  \n", "```{r, echo=FALSE, warning=FALSE}", "  \n",
      'temp_plot', "  \n", "```", "  \n", sep = "")
  sink()

# ---------- knit using knit_child function
  # Knit the temporary RMD file
  cat(knitr::knit_child(temp_rmd_list[[idx_metabolite]],
                        quiet = TRUE))

  # Delete the temporary RMD files
  file.remove(temp_rmd_list[[idx_metabolite]])
}

```

## Perform calibration

Following calibration, metabolites are assigned either:

-   Concentration values: metabolite has an external calibration dilution series using response values created by calculating a ratio with the peak area of a matched (or surrogate) stable isotope labelled internal standard. Metabolites have passed quality control assessment consisting of:

    -   r2 value \> 0.99

    -   minimum of 6 calibration points with a residual deviation \<25% from expected concentration

    -   minimum of 2 analytical QC with a residual deviation \<25% from expected concentration

-   Response values: metabolite has an external calibration dilution series using response values created by calculating a ratio with the peak area of a matched (or surrogate) stable isotope labelled internal standard. Metabolites have failed quality control assessment described above.

-   Peak area: metabolite does not have an external calibration dilution series and does not use a stable isotope labelled internal standard.

### Concentration

```{r report - cal, eval=FALSE, echo=TRUE, paged.print=FALSE, warning=FALSE, results='asis'}

# -------------- create combined widget of cal plots and summary table and knit to report
  #make empty list in master list
mstr_lst$report <- list(
  conc = list(),
  response = list(),
  test = list()
)

#create empty rmd list for knit_child workaround
temp_rmd_list <- list()

#run loop for each metabolite that passes QC
for(idx_metabolite in names(mstr_lst$calib$conc)){
  plot_row_freq <- ceiling(length(unique(mstr_lst$calib$conc[[idx_metabolite]]$all_plates$summary$plate))/3)
  mstr_lst$report$conc[[idx_metabolite]] <- combineWidgets(
   mstr_lst$calib$conc[[idx_metabolite]]$all_plates$plot$calib, # calib plots
  #mstr_lst$calib$conc[[idx_metabolite]]$all_plates$plot$control_chart, #control chart plots
  #combine with kable of summary table
mstr_lst$calib$conc[[idx_metabolite]]$all_plates$summary %>%
  kbl(align = "c", booktabs = TRUE, longtable = TRUE) %>%
  kable_minimal("hover") %>%
  kable_styling(font_size = 10) %>%
  scroll_box(width = "750px"),
#CombineWidegets properties
height = (plot_row_freq+1) * 400,
width = 800,
rowsize = c(plot_row_freq,1),
ncol = 1
)
  
# ----------- Create temp rmd file as a work around for rendering dynamic html widgets from a loop
  temp_rmd_path <- paste0(mstr_lst$proj_optns$proj_dir, idx_metabolite, ".rmd")
  temp_rmd_list[[idx_metabolite]] <- temp_rmd_path
  sink(file = temp_rmd_path)
  cat("  \n", "### ", idx_metabolite, "  \n", "```{r, echo=FALSE, warning=FALSE}", "  \n",
      'mstr_lst$report$conc[[idx_metabolite]]', "  \n", "```", "  \n", sep = "")
  sink()

# ---------- knit using knit_child function
  # Knit the temporary RMD file
  cat(knitr::knit_child(temp_rmd_list[[idx_metabolite]],
                        quiet = TRUE))

  # Delete the temporary RMD files
  file.remove(temp_rmd_list[[idx_metabolite]])
}
```

### Response

```{r report - response, eval=FALSE, echo=TRUE, paged.print=FALSE, warning=FALSE, results='asis'}

# -------------- create combined widget of cal plots and summary table and knit to report

#create empty rmd list for knit_child workaround
temp_rmd_list <- list()

#run loop for each metabolite that passes QC
for(idx_metabolite in names(mstr_lst$calib$response)){
  plot_row_freq <- ceiling(length(unique(mstr_lst$calib$response[[idx_metabolite]]$all_plates$summary$plate))/3)
  mstr_lst$report$response[[idx_metabolite]] <- combineWidgets(
   mstr_lst$calib$response[[idx_metabolite]]$all_plates$plot$calib,
   #mstr_lst$calib$response[[idx_metabolite]]$all_plates$plot$control_chart,
#CombineWidegets properties
height = (plot_row_freq+1) * 400,
width = 800,
rowsize = c(plot_row_freq,1),
ncol = 1
)
  
# ----------- Create temp rmd file as a work around for rendering dynamic html widgets from a loop
  
  temp_rmd_path <- paste0(mstr_lst$proj_optns$proj_dir, idx_metabolite, ".rmd")
  temp_rmd_list[[idx_metabolite]] <- temp_rmd_path
  sink(file = temp_rmd_path)
  cat("  \n", "### ", idx_metabolite, "  \n", "```{r, echo=FALSE, warning=FALSE}", "  \n",
      'mstr_lst$report$response[[idx_metabolite]]', "  \n", "```", "  \n", sep = "")
  sink()

# ---------- knit using knit_child function
  # Knit the temporary RMD file
  cat(knitr::knit_child(temp_rmd_list[[idx_metabolite]],
                        quiet = TRUE))

  # Delete the temporary RMD files
  file.remove(temp_rmd_list[[idx_metabolite]])
}
```

### Area

```{r report - area, eval=FALSE, echo=TRUE, paged.print=FALSE, warning=FALSE, results='asis'}

# -------------- create combined widget of cal plots and summary table and knit to report
#create empty rmd list for knit_child workaround
temp_rmd_list <- list()

#run loop for each metabolite that passes QC
for(idx_metabolite in names(mstr_lst$calib$area)){
  plot_row_freq <- ceiling(length(unique(mstr_lst$calib$area[[idx_metabolite]]$all_plates$summary$plate))/3)
  mstr_lst$report$area[[idx_metabolite]] <- combineWidgets(
   #mstr_lst$calib$area[[idx_metabolite]]$all_plates$plot$control_chart,
  #combine with kable of summary table
#CombineWidegets properties
height = 400,
width = 800,
rowsize = c(1),
ncol = 1
)
  
# ----------- Create temp rmd file as a work around for rendering dynamic html widgets from a loop
  
  temp_rmd_path <- paste0(mstr_lst$proj_optns$proj_dir, idx_metabolite, ".rmd")
  temp_rmd_list[[idx_metabolite]] <- temp_rmd_path
  sink(file = temp_rmd_path)
  cat("  \n", "### ", idx_metabolite, "  \n", "```{r, echo=FALSE, warning=FALSE}", "  \n",
      'mstr_lst$report$response[[idx_metabolite]]', "  \n", "```", "  \n", sep = "")
  sink()

# ---------- knit using knit_child function
  # Knit the temporary RMD file
  cat(knitr::knit_child(temp_rmd_list[[idx_metabolite]],
                        quiet = TRUE))

  # Delete the temporary RMD files
  file.remove(temp_rmd_list[[idx_metabolite]])
}
```

```{r LTR analysis, eval = FALSE}

#------------- FUNCTION to create LTR control chart

control_plotR <- function(FUNC_data,
                          FUNC_plot_header,
                          FUNC_y_title){
  
FUNC_data <- FUNC_data %>%
    #crop plate order
    add_column(
      plate_id = (lapply(str_split(FUNC_data$name, "_"), function(x) head(x, n=6))) %>% 
        lapply(., function(x) tail(x, n=1)) %>% unlist(),
      run_order = lapply(str_split(FUNC_data$name, "_"), function(x) tail(x, n=1)) %>% unlist() %>% as.numeric()
    ) %>%
    arrange(plate_id, run_order) %>% 
    add_column(sample_idx = factor(1:nrow(.), ordered = TRUE)) %>%
    rename_at(FUNC_plot_header, list(~paste0("y_data")))
  
  #find LTRs
  FUNC_data$type[grep("LTR", FUNC_data$name)] <- "LTR"
  
  #find plate IDX for plate vlines
  plate_idx <- NULL
  for(idx_plate in unique(FUNC_data$plate)){
    plate_idx <- c(plate_idx,
                   max(which(FUNC_data$plate == idx_plate)))
  }
  plate_idx <- (plate_idx[1:length(plate_idx)-1])+0.5
  
  #find values for hlines
  #median LTR conc
  LTR_median = (FUNC_data %>% filter(type == "LTR"))[["y_data"]] %>% median()
  #LTR std.dev 
  LTR_sd = (FUNC_data %>% filter(type == "LTR"))[["y_data"]] %>% sd()
  #calcluate 1x and 2x sd range
  LTR_1sd_range = c((LTR_median - LTR_sd), (LTR_median + LTR_sd))
  LTR_2sd_range = c((LTR_median - LTR_sd*2), (LTR_median + LTR_sd*2))
  
  #create plot
  FUNC_plot <- ggplot(data = FUNC_data,
                      aes(x=sample_idx, y=log(y_data+1), fill = type, shape=type, size=type)) +
    geom_point(color = "black") +
    geom_vline(xintercept = plate_idx) +
    geom_hline(yintercept = log(LTR_median+1), color = "orange") +
    geom_hline(yintercept = log(LTR_1sd_range+1), color = "orange", linetype = "dashed") +
    geom_hline(yintercept = log(LTR_2sd_range+1), color = "orange", linetype = "dotted") +
    theme_classic() +
    labs(y = paste0("log(", FUNC_y_title, ")"))+
    theme(plot.title = element_blank(),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          legend.text = element_text(size = 5),
          legend.title = element_text(size = 5),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank()) +
    scale_x_discrete(expand = c(0.02,0.02)) +
    scale_fill_manual(values=c("black", "orange")) +
    scale_shape_manual(values = c(3, 21)) +
    scale_size_manual(values = c(1,2.5))
  
  ggplotly(FUNC_plot)  
 
}

# ---------------- #plots

#create control chart - conc
   temp_lst$all_plates$plot$control_chart <- control_plotR(FUNC_data = temp_lst$all_plates$lmX_pred_data %>% 
                                                             filter(type == "Analyte"),
                                                           FUNC_plot_header = "calc_conc",
                                                           FUNC_y_title = "concentration")


         #create control chart response
   temp_lst$all_plates$plot$control_chart <- control_plotR(
     FUNC_data = temp_lst$all_plates$lmX_pred_data %>%
       filter(type == "Analyte"),
     FUNC_y_title = "response",
     FUNC_plot_header = "response")

      #create control chart area
   temp_lst$all_plates$plot$control_chart <- control_plotR(
     FUNC_data = mstr_lst$data$calib %>% 
       select(plate, name, type, all_of(paste0(idx_metabolite, "_AREA"))) %>%
       rename_at(paste0(idx_metabolite, "_AREA"), list(~paste0("calc_conc"))) %>% 
       filter(type == "Analyte"),
     FUNC_plot_header = "calc_conc",
     FUNC_y_title = "area")

```

# SPACE - NOT COMPLETE BELOW THIS LINE

<!--# comment: IGNORE BELOW THIS LINE FOR NOW -->

```{r load packages and set up project structure, eval=FALSE, echo=TRUE, paged.print=TRUE, warning=FALSE, results = 'asis'}

#### load packages
package_list <- c('tidyverse', 'janitor', 'qualV', 'kableExtra', '')

for(idx_package in package_list){
  if(length(which(row.names(installed.packages()) == idx_package)) > 0){
  suppressMessages(require(package = idx_package,
                                         character.only = TRUE))
  } else {
    paste0(idx_package, " is not installed. Please install ", idx_package, " before continuing.") %>% print()
  }
}

#string for function directory
func_dir = "/Users/lukegraywhiley/Documents/GitHub/metabolomics_code/functions/"

#filelist of datafiles from project path to undergo analysis. Data must be stored in appropiate subfolder.
data_filelist <- list.files(path = paste0(mstr_lst$proj_optns$proj_dir,
                                          mstr_lst$proj_optns$proj_data_subdir),
                            pattern = ".txt",
                            full.names = TRUE)

#set up project list structure and append colours (autogenerated using brewer.pal)
mstr_lst <- lst(proj_details = mstr_lst$proj_optns %>%
                     list_modify(., 
                                 proj_colours = brewer.pal(n= length(.[["proj_classes"]]), name = "Accent"),
                                 sub_projects = array(dim = length(data_filelist))),
                   functions = lst(
                     LGW_FUNC_dataRead = source(paste0(func_dir ,"LGW_FUNC_dataRead.R")),
                     LGW_FUNC_impute = source(paste0(func_dir, "LGW_FUNC_impute_halfmin.R")),
                     LGW_FUNC_pca = source(paste0(func_dir, "Quarto_LGW_FUNC_rPCA.R")),
                     LGW_FUNC_rOPLS = source(paste0(func_dir, "Quarto_LGW_FUNC_rOPLS.R")),
                     LGW_FUNC_univariate = source(paste0(func_dir, "2021_LGW_FUNC_compare_means_ggplot_boxplots.R"))
                     ),
                   tables = lst(proj_overview = lst()))

# read in data


#execute function
for(idx_filepath in 1:length(data_filelist)){
  mstr_lst$proj_details$sub_projects[idx_filepath] <- gsub(x = strsplit(data_filelist[idx_filepath], paste0(mstr_lst$proj_details$proj_data_subdir, "/"))[[1]][2], pattern = ".csv", replacement = "")
 
  mstr_lst[[mstr_lst$proj_details$sub_projects[idx_filepath]]] <- lst(
    data = lst(
      master_data = mstr_lst$functions$LGW_FUNC_dataRead$value(
        FUNC_datapath = data_filelist[idx_filepath],
        FUNC_annotation_tag = "sample"),
      sample_filtered = lst(),
      feature_filtered = lst(),
      imputed_data = lst()
  ))
  
  idx_data <- mstr_lst$proj_details$sub_projects[idx_filepath]
  
#add factor columns for control of colours for plotting
  mstr_lst[[idx_data]]$data$master_data$annotation <- mstr_lst[[idx_data]]$data$master_data$annotation %>%
    #sample_class
    mutate(across(.cols = all_of(mstr_lst$proj_details$proj_class_column_header),
                  .fns = ~factor(.x, levels = c(mstr_lst$proj_details$proj_classes), ordered = TRUE),
                  .names = "sample_class_factor")) %>%
    #sample type
    mutate(across(.cols = sample_type,
                  .fns = ~factor(.x, levels = c("qc", "sample"), ordered = TRUE),
                  .names = "sample_type_factor")) %>%
    #sample_batch
    mutate(across(.cols = sample_batch,
                  .fns = ~factor(.x, levels = unique(.), ordered = TRUE),
                  .names = "sample_batch_factor"))
             
  #filter to only include sample classes desired by user
        #find idx of rows containg sample_class defined by user as proj_classes in chunk 1.
  keep_idx_class <- which(
    mstr_lst[[idx_data]]$data$master_data$annotation[[mstr_lst$proj_details$proj_class_column_header]] %in% mstr_lst$proj_details$proj_classes)

    #run apply to remove sample classes not desired by user
  mstr_lst[[idx_data]]$data$master_data[1:2] <- lapply(
    X = mstr_lst[[idx_data]]$data$master_data[1:2], 
    FUN = function(x) x[keep_idx_class,])
  
  #create summary tibble for printing
  mstr_lst$tables$proj_overview <- mstr_lst$tables$proj_overview %>%
    bind_rows(., tibble(
      project = idx_data,
      features = ncol(mstr_lst[[idx_data]]$data$master_data$data),
      total_samples = nrow(mstr_lst[[idx_data]]$data$master_data$annotation),
      qc_samples = nrow(mstr_lst[[idx_data]]$data$master_data$annotation %>% 
                          filter(sample_type =="qc")),
      study_samples = nrow(mstr_lst[[idx_data]]$data$master_data$annotation %>% 
                             filter(sample_type =="sample"))
      ) %>% bind_cols(.,
      mstr_lst[[idx_data]]$data$master_data$annotation[[mstr_lst$proj_details$proj_class_column_header]] %>%
        table() %>% as.matrix %>% t %>% as_tibble())
    )
  
  #set result lst for exporting results
  mstr_lst[[idx_data]]$results <- lst()
  }


#print table for report
mstr_lst$tables$proj_overview %>% 
  kbl(align = "c") %>% 
  kable_minimal("hover", full_width = T)
```

## Sample outlier removal

```{r sample outlier removal, eval = FALSE, echo = TRUE, warning=FALSE}

# this chunk is to subset data, removing outliers
# if no outliers - set as NA

#set empty list
mstr_lst$tables$proj_overview_filtered <- lst()

for(idx_data in mstr_lst$proj_details$sub_projects){
  
  if(is.na(mstr_lst$proj_details$proj_outliers)){
  mstr_lst[[idx_data]]$data$sample_filtered <- mstr_lst[[idx_data]]$data$master_data
  mstr_lst$tables$proj_overview_filtered <- mstr_lst$tables$proj_overview
  #cat("No outliers removed")
  } else {
  
  #find idx of rows containg sample_class defined by user as proj_classes in chunk 1.
  keep_idx_class <- which(mstr_lst[[idx_data]]$data$master_data$annotation[[mstr_lst$proj_details$proj_class_column_header]] %in% mstr_lst$proj_details$sample_class)  
  #find idx of rows that are not outliers defined by user as proj_outliers in chunk 1.
  keep_idx_outlier <- which(!mstr_lst[[idx_data]]$data$master_data$annotation$sample_name %in% mstr_lst$proj_details$proj_outliers)

  #run apply to remove outliers
  mstr_lst[[idx_data]]$data$sample_filtered[1:2] <- lapply(X = mstr_lst[[idx_data]]$data$master_data[1:2], 
                                                            FUN = function(x) x[keep_idx_outlier,])
  
  #add feature list to filtered data
   mstr_lst[[idx_data]]$data$sample_filtered[3] <-  mstr_lst[[idx_data]]$data$master_data[3]
  
     mstr_lst$tables$proj_overview_filtered <- mstr_lst$tables$proj_overview_filtered %>%
    bind_rows(.,
              tibble(project = (mstr_lst[[idx_data]]$data$sample_filtered %>% names()),
                     features = ncol(mstr_lst[[idx_data]]$data$sample_filtered$data),
                     total_samples = nrow(mstr_lst[[idx_data]]$data$sample_filtered$annotation),
                     qc_samples = nrow(mstr_lst$data$master_data[[idx_filepath]]$annotation %>% filter(sample_type =="qc")),
                     study_samples = nrow(mstr_lst[[idx_data]]$data$sample_filtered$annotation %>% filter(sample_type =="sample"))
                     ) %>%
                bind_cols(. ,
                          mstr_lst[[idx_data]]$data$sample_filtered$annotation[[mstr_lst$proj_details$proj_class_column_header]] %>% table() %>% as.matrix %>% t %>% as_tibble())
              )
  }
}

#clean environment
rm(list = c(ls()[which(ls() != "mstr_lst")]))

if(is.na(mstr_lst$proj_details$proj_outliers)){cat("No outliers removed")} else {
  cat("Updated sample table:")
  mstr_lst$tables$proj_overview_filtered %>% 
  kbl(align = "c") %>% 
  kable_minimal("hover", full_width = T)
}
```

## Feature outlier removal

-   Features are removed that have \> 50% missing values

-   Removed features:

```{r feature outlier removal, eval = FALSE, echo = TRUE, warning=FALSE}

#remove features that have > x missing values

for(idx_data in mstr_lst$proj_details$sub_projects){
  #set data
  mstr_lst[[idx_data]]$data[["feature_filtered"]] <- mstr_lst[[idx_data]]$data$sample_filtered
  
  #get names of metabolites with >50% missing values
mstr_lst[[idx_data]]$data$feature_filtered[["failed_features"]] <- which(
  (colSums(is.na(mstr_lst[[idx_data]]$data$sample_filtered$data))/
     nrow(mstr_lst[[idx_data]]$data$sample_filtered$data))*100 > 50) %>% names()
 
mstr_lst[[idx_data]]$data[["feature_filtered"]]$data <-  mstr_lst[[idx_data]]$data[["feature_filtered"]]$data %>%
  select(-all_of(mstr_lst[[idx_data]]$data$feature_filtered[["failed_features"]]))

mstr_lst[[idx_data]]$data[["feature_filtered"]]$features <- mstr_lst[[idx_data]]$data[["feature_filtered"]]$data %>%
  names()
}

mstr_lst[[idx_data]]$data$feature_filtered[["failed_features"]]
```

## Missing value and imputation overview

-   Missing values also include NA, NaN and zeros

-   Missing values are treated as \< lower limit of detection (LLOD)

-   Imputation is computed individually for each metabolite.

-   Missing values are filled using the half minimum concentration value for each metabolite.

```{r missing value overview and impute, eval = FALSE, echo = TRUE}

mstr_lst$functions$LGW_FUNC_impute <- source('/Users/lukegraywhiley/Documents/GitHub/metabolomics_code/functions/LGW_FUNC_impute_halfmin.R')

#set empty table for output
mstr_lst$tables$missing_values_table <- lst()

#run impution loop for each dataset
for(idx_data in mstr_lst$proj_details$sub_projects){
      mstr_lst[[idx_data]]$data$imputed_data <- list(
        annotation = mstr_lst[[idx_data]]$data$feature_filtered$annotation,
        data = mstr_lst$functions$LGW_FUNC_impute$value(x = mstr_lst[[idx_data]]$data$feature_filtered$data),
        features = mstr_lst[[idx_data]]$data$feature_filtered$features
      )
  
      #create table for report
      
      #1. data to shorthand object
      pre_data <- mstr_lst[[idx_data]]$data$feature_filtered$data
      pre_data_missing <- length(which(pre_data==0)) + length(which(is.na(pre_data)))
      post_data <- mstr_lst[[idx_data]]$data$imputed_data$data
      post_data_missing <- length(which(post_data==0)) + length(which(is.na(post_data)))
      
    
      #. calculate output table
    mstr_lst$tables$missing_values_table <- mstr_lst$tables$missing_values_table %>%
      bind_rows(., bind_cols(
        "project" = idx_data,
        "pre-impute: missing values (%)" = paste0(pre_data_missing, " (", round((100/prod(dim(pre_data)))*pre_data_missing,2),")"),
        "post-impute: missing values (%)" = paste0(post_data_missing, " (", round((100/prod(dim(post_data)))*post_data_missing,2),")")
        ))
}


#clean environment
rm(list = c(ls()[which(ls() != "mstr_lst")]))

#print table for report
mstr_lst$tables$missing_values_table %>% 
  kbl(align = "c") %>% 
  kable_minimal("hover", full_width = T)

```

<br />

## Results

### Multivariate data analysis

#### Principal Component Analysis (PCA)

-   Principal Component Analysis (PCA) was conducted to check the quality of the data. PCA is an unsupervised model (i.e. no prior group information is supplied to the model, labelling and colours applied after the model construction). This allows for observations on the quality of the dataset

-   Patterns in the data between samples can also be observed - this may be as a result of either biological or analytical differences - e.g. differences in sample collection, handling or storage

##### Pre-processed data - no batch or signal drift correction

```{r PCA, eval = FALSE, echo = TRUE, warning = FALSE}

#create a html taglist (work around for rendering plotly html in a loop in .RMD documents) and set up iterative idx (i)
print_lst <- htmltools::tagList(); i <- 1

#run loop
for(idx_data in mstr_lst$proj_details$sub_projects){
  #pca_lst to store PCA settings for loop
  pca_lst <- lst(
    "sample type" = lst(header = "sample_type_factor", include_qc = TRUE, include_sample = TRUE,
                        plot_colours = c("steelblue1", "white")),
    "batch [all samples]" = lst(header = "sample_batch_factor", include_qc = TRUE, include_sample = TRUE,
                                plot_colours = c(brewer.pal(n = length(unique(
                                  mstr_lst[[idx_data]]$data$imputed_data$annotation$sample_batch_factor)), name = "Accent"))),
    "batch [qc samples only]" = lst(header = "sample_batch_factor", include_qc = TRUE, include_sample = FALSE,
                                    c(brewer.pal(n = length(unique(
mstr_lst[[idx_data]]$data$imputed_data$annotation$sample_batch_factor)), name = "Accent"))),
    "sample class" = lst(header = "sample_class_factor", include_qc = TRUE, include_sample = TRUE,
                         plot_colours = mstr_lst$proj_details$proj_colours[which(
                           levels(mstr_lst[[idx_data]]$data$imputed_data$annotation$sample_class_factor) %in%
                             unique( mstr_lst[[idx_data]]$data$imputed_data$annotation[[mstr_lst$proj_details$proj_class_column_header]]))]),
  )

  # complete PCA analysis
  for(idx_pca in names(pca_lst)){
    mstr_lst[[idx_data]]$results$pca[[idx_pca]] <- mstr_lst$functions$LGW_FUNC_pca$value(
                    FUNC_data = bind_cols(mstr_lst[[idx_data]]$data$imputed_data$annotation, 
                                          mstr_lst[[idx_data]]$data$imputed_data$data),
                    FUNC_metabolite_list = mstr_lst[[idx_data]]$data$imputed_data$features,
                    FUNC_STRING_title = paste0("PCA (coloured by ",idx_pca,"); ", idx_data),
                    FUNC_STRING_legend_title = idx_pca,
                    FUNC_HEADER_colour_by = pca_lst[[idx_pca]]$header,
                    FUNC_HEADER_plot_label = "sample_id",
                    FUNC_OPTION_scaling = "standard",
                    FUNC_OPTION_log_data = TRUE,
                    FUNC_OPTION_plot_colours = pca_lst[[idx_pca]]$plot_colours,
                    FUNC_OPTION_invert_x = FALSE,
                    FUNC_OPTION_invert_y = FALSE,
                    FUNC_OPTION_include_qc = pca_lst[[idx_pca]]$include_qc,
                    FUNC_OPTION_include_sample = pca_lst[[idx_pca]]$include_sample
    )
        print_lst[[i]] <- mstr_lst[[idx_data]]$results$pca[[idx_pca]]$plot_combined; i <- i+1
      }}
  
print_lst

```

#### Orthogonal Projections to Latent Structures Discriminant Analysis (OPLS-DA)

-   Orthogonal Projections to Latent Structures Discriminant Analysis (OPLS-DA) was conducted to identify separation between the groups

-   OPLS-DA is a supervised model, where groups are pre-defined before modelling. It can be used as a classifier to see observe differences in the metabolite data that exist between the two classes e.g. (control vs case).

```{r OPLS-DA, eval = FALSE, echo = TRUE,  warning=FALSE, results='asis'}

#create a html taglist (work around for rendering plotly html in a loop in .RMD documents) and start iterative idx for printing
print_list <- htmltools::tagList(); i <- 1

for(idx_data in mstr_lst$proj_details$sub_projects){ 
  mstr_lst[[idx_data]]$results$opls <- lst()
  #create OPLS-DA
  mstr_lst[[idx_data]]$results$opls <- mstr_lst$functions$LGW_FUNC_rOPLS$value(
    FUNC_data = bind_cols(mstr_lst[[idx_data]]$data$imputed_data$annotation,
                          mstr_lst[[idx_data]]$data$imputed_data$data), 
    FUNC_metabolite_list = mstr_lst[[idx_data]]$data$imputed_data$features,
    FUNC_OPLS_comparison_control = mstr_lst$proj_details$opls$control,
    FUNC_OPLS_comparison_test = mstr_lst$proj_details$opls$case,
    FUNC_HEADER_class = "sample_class_factor",
    FUNC_OPTION_colour_by = "sample_class_factor",
    FUNC_OPTION_plot_label = "sample_id",
    FUNC_OPTION_scaling = "pareto",
    FUNC_OPTION_log_data = TRUE,
    FUNC_OPTION_title = "",
    FUNC_OPTION_proj_colours = mstr_lst$proj_details$proj_colours,
    FUNC_OPTION_max_orth = 1,
    FUNC_OPTION_invert_x = FALSE,
    FUNC_OPTION_invert_y = FALSE
  )
 
  #add to print list for rendering in report, add iterative idx
  for(idx_case in names(mstr_lst[[idx_data]]$results$opls)){
  print_list[[i]] <- mstr_lst[[idx_data]]$results$opls[[idx_case]]$plot_combined; i <- i+1
  print_list[[i]] <- mstr_lst[[idx_data]]$results$opls[[idx_case]]$loading_bar; i <- i+1
}
}
print_list

```

### Univariate analysis

-   Inter-group means were compared using non-parametric analysis (Kruskal-Wallis)\
-   Individual lipids that returned a p value of \< 0.05, then underwent analysis using Dunn's test, to report specific inter-group differences\
-   Significant lipids from the test are displayed in the table

#### Results table

<br />

```{r compare means, eval=FALSE, echo=TRUE, warning=FALSE, error=FALSE, message=FALSE,results='asis'}

for(idx_data in mstr_lst$proj_details$sub_projects){
  mstr_lst[[idx_data]]$results$univariate <- lst()

#create a html taglist (work around for rendering kable html in a loop in .RMD documents) and start iterative idx for printing
print_list <- htmltools::tagList(); i <- 1
  #find project colours to use to consistently match PCA and OPLS
  plot_colours <- mstr_lst$proj_details$proj_colours[which(
    levels(mstr_lst[[idx_data]]$data$imputed_data$annotation$sample_class_factor) %in% mstr_lst$proj_details$univariate$comparison)]

    #perform univariate and stats 
  mstr_lst[[idx_data]]$results$univariate <- mstr_lst$functions$LGW_FUNC_univariate$value(
    FUNC_data = bind_cols(mstr_lst[[idx_data]]$data$imputed_data$annotation,
                          mstr_lst[[idx_data]]$data$imputed_data$data),
    FUNC_metabolite_list = mstr_lst[[idx_data]]$data$imputed_data$features,
    FUNC_class_to_include = mstr_lst$proj_details$univariate$comparison,
    FUNC_HEADER_class = "sample_class_factor",
    FUNC_HEADER_colour = "sample_class_factor",
    FUNC_OPTION_colour_choice <- plot_colours, 
    FUNC_OPTION_log_plot_data = FALSE,
    FUNC_OPTION_compare_means_method = mstr_lst$proj_details$univariate$method, #OPTIONS = kruskal.test, wilcox.test, wilcox.test.paired
    FUNC_HEADER_paired = NA, #if paired test is desired add here the linking column header, else = NA
    FUNC_plot_comparisons = NA, ##only required for specific Mann.Whitney; e.g. c("admission - presurgery")
    FUNC_OPTION_plot_qc = FALSE,
    FUNC_OPTION_plot_show_legend = FALSE,
    FUNC_OPTION_plot_outliers = FALSE,
    FUNC_OPTION_point_size = 1
)
  
  # p value control for multiple testing
  mstr_lst[[idx_data]]$results$univariate$table <- mstr_lst[[idx_data]]$results$univariate$table %>%
    select(-"p.adj", - "p.format") %>%
    add_column(padj = p.adjust(p =  mstr_lst[[idx_data]]$results$univariate$table$p, method = "BH"), 
               .after = "p") %>%
    arrange(p)
  
  #add kable to print_list for report
mstr_lst[[idx_data]]$results$univariate$table %>%
  kbl(align = "c", booktabs = TRUE, longtable = TRUE) %>%
  kable_minimal("hover") %>%
  kable_styling(font_size = 10) %>%
  scroll_box(height = "500px") %>% print()


}




```

#### Univariate boxplots

-   Boxplots for metabolites that returned a Kruskal Wallis \<0.05 are displayed below

-   The False Discovery Rate was controlled using the method proposed by Bejamini and Hochburg

Boxplot annotation:\
\* = p\<0.05\
\*\* = p\<0.01\
\*\*\* = p\<0.001\
\*\*\*\* = p\<0.0001

```{r print boxplots, eval=FALSE, echo=TRUE, warning=FALSE, error=FALSE, message=FALSE,results='asis', fig.width=2.8, fig.height=2.8, out.height="80%", out.width = "80%", dpi=300, fig.show="hold"}

  #print sig boxplots
  for(idx_data in mstr_lst$proj_details$sub_projects){
sig_max <- which(mstr_lst[[idx_data]]$results$univariate$table$padj <0.05) %>% max()
for (idx_plot in mstr_lst[[idx_data]]$results$univariate$table$feature[1:sig_max]){
print(mstr_lst[[idx_data]]$results$univariate$bp[[idx_plot]])
}
}

```
